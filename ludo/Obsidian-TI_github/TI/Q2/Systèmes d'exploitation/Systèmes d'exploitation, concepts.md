# ordonnancement
## Définition
### Le problème
• Quand doit-on stopper un processus s'exécutant sur un CPU ?  
• Quel processus va continuer sur ce CPU ?  
• Mêmes questions pour les threads d'un processus.  
• Que se passe t’il avec plusieurs processeurs ?
### Les objectifs
✓ Maximiser le taux d'occupation du processeur  
✓ Minimiser le temps de réponse des processus  
Critères d'évaluations de l’ordonnancement :  
• Temps d'attente des processus  
• Débit du processeur  
• Temps de réponse moyen  
• Temps de traitement d'un ensemble de processus
### Les critères d'ordonnancement
Il y aura normalement plusieurs processus dans la file prêt  
Quand le CPU devient disponible, lequel choisir?  
Critères généraux:  
• Bonne utilisation du CPU  
• Réponse rapide à l’usager
Il y a aussi des critères spécifiques d’ordonnancement :  
Utilisation UCT: pourcentage d’utilisation (à maximiser).  
Débit = Throughput: nombre de processus qui s’exécutent complètement dans l’unité  
de temps (à maximiser).  
Temps de rotation = turnaround: le temps pris par le processus de son arrivée à sa  
fin (à minimiser).  
Temps d’attente: attente dans la file prêt (somme de tout le temps passé en file prêt)  
(à minimiser).  
Temps de réponse (pour les systèmes interactifs): le temps entre une demande et la  
réponse (à minimiser).
Nous distinguons deux types d’ordonnancement (concerne l’ordonnancement a court  
terme) :  
• Les mécanismes non-préemptifs qui n’interrompent pas le fonctionnement d’un  
processus : seul l’attente sur une entrée/sortie (qui peut stopper le fonctionnement  
d’un processus) et la fin d’un processus peuvent provoquer l’appel de l’ordonnanceur.  
• Les mécanismes préemptifs qui peuvent interrompre le fonctionnement d’un  
processus ce qui suppose la mise en place d’un timer et des méthodes plus  
complexes de gestion des changements de contexte.
### ordonnanceur et répartiteur
![[Pasted image 20230321125943.png]]
![[Pasted image 20230321130008.png]]
### parallélisme réel et pseudo-parallélisme
![[Pasted image 20230321130037.png]]
## Les mécanismes
### Premier arrivé, premier servi FCFS (ou FIFO) sans ou avec réquisition
#### exemple
![[Pasted image 20230321130235.png]]
#### autre exemple
![[Pasted image 20230321130330.png]]
• Donc dans un sens FCFS favorise les  
processus tributaires du CPU et peut  
conduire à une très mauvaise utilisation des  
ressources tant du CPU que de  
périphériques.  
• Une possibilité: interrompre de temps en  
temps les processus tributaires du CPU pour  
permettre aux autres processus d’exécuter  
(préemption)
### Plus court d'abord
Ce mécanisme consiste à sélectionner le processus nécessitant le moins de temps  
d’exécution (le prochain Burst CPU le plus court). Il existe deux approches :  
• Non-préemptive ; le processus qui prend le contrôle de l’UC ne le quitte qu’à la fin de  
son exécution ou lorsqu’il est bloqué.  
• Préemptive : si un nouveau processus arrive dont la durée prévue est inférieure au  
temps restant d’exécution du processus en cours, ce nouveau processus obtient le  
contrôle du CPU (on parle alors de SRIF, Shortest Remaining Time First)
#### Exemple
![[Pasted image 20230321130423.png]]
![[Pasted image 20230321130445.png]]
![[Pasted image 20230321130502.png]]
#### Exercices 1
![[Pasted image 20230321130631.png]]
![[Pasted image 20230321130645.png]]
#### Exercice 2
![[Pasted image 20230321130719.png]]
![[Pasted image 20230321130730.png]]
![[Pasted image 20230321130745.png]]
![[Pasted image 20230321130757.png]]
![[Pasted image 20230321130809.png]]
![[Pasted image 20230321130822.png]]
![[Pasted image 20230321130833.png]]
![[Pasted image 20230321130843.png]]
### Par priorités constantes
Par priorités constantes  
• chaque processus reçoit une priorité  
• le processus de plus forte priorité est élu  
Avec ou sans réquisition (préemption)
![[Pasted image 20230321130924.png]]
#### Exercice3
![[Pasted image 20230321130948.png]]
![[Pasted image 20230321131002.png]]
### Par priorité : Rate Monotonic
![[Pasted image 20230321131102.png]]
### Par tourniquet (round robin)
• Ce mécanisme est particulièrement utilisé  
dans les systèmes à temps partagé. Le  
planificateur alloue à tour de rôle à chaque  
processus un quota de temps du CPU (10 –  
100 ms).  
• Le processus en cours peut s'interrompre  
pour des raisons internes (ex : accès a un  
périphérique, fin du processus, etc) ou  
parce que le quota de temps alloué s'est  
écoulé. Dans le second cas il est remis  
dans la queue des processus prêts.
#### exemple
![[Pasted image 20230321131130.png]]
#### autre exemple
![[Pasted image 20230321131148.png]]
### Par files de priorités de priorités constantes multiniveaux avec ou sans extinction de priorité
L’ordonnancement  
Les mécanismes  
• Chaque file est associée à un quantum de temps éventuellement différent  
• sans extinction : un processus garde toujours la même priorité  
• avec extinction : la priorité d'un processus décroit en fonction de son utilisation du cpu
![[Pasted image 20230321131303.png]]
![[Pasted image 20230321131323.png]]

### Ordonnancement : système LINUX

![[Pasted image 20230321131424.png]]
## ex de cette partie
![[Système exploit theorie_230310_135602.pdf]]

# gestion de la mémoire
## La fonction de mémorisation
Trois problèmes à résoudre vis-à-vis de la  
mémoire :  
❑Définir un espace d'adressage indépendant  
pour chaque processus  
❑Protéger les espaces d'adressages des processus  
entre eux  
❑Allouer de la mémoire physique à chaque espace  
d'adressage
## Le chargement dynamique en mémoire
![[Pasted image 20230315191402.png]]
![[Pasted image 20230315191426.png]]
## Le découpage de la mémoire
La mémoire centrale peut-être découpée de trois façons :  
◼ la segmentation : les programmes sont découpés en  
parcelles ayant des longueurs variables appelées  
«segments».  
◼ la pagination : elle consiste à diviser la mémoire en  
blocs, et les programmes en pages de longueur fixe.  
◼ une combinaison de segmentation et de pagination :  
certaines parties de la mémoires sont segmentées, les  
autres sont paginées.
## Organisation de la mémoire d’un processus
![[Pasted image 20230315191540.png]]
Le segment de code  
	Le segment de code est obtenu en copiant directement  
	en mémoire le segment de code du fichier exécutable.  
	Au cours de l'exécution du programme, la prochaine  
	instruction à exécuter est repérée par un pointeur  
	d'instruction.
Le segment de données  
	Au dessus du segment de code se trouve le segment  
	de données.  
	Ce segment est traditionnellement composé d'un  
	segment de données initialisées (data), qui est  
	directement copié à partir de l'exécutable, et d'un  
	segment de données non initialisées (bss pour block  
	storage segment) qui est créé dynamiquement.
![[Pasted image 20230315191655.png]]
	Les données initialisées correspondent à toutes les  
	variables globales et statiques initialisées des programmes  
	C. Les données non initialisées correspondent aux  
	variables globales et statiques non initialisées.  
	Le segment de données peut être agrandi ou réduit au  
	cours de l'exécution pour permettre d'y placer des  
	données. Néanmoins, il est habituel de considérer que ce  
	segment est fixe et correspond à celui obtenu avant  
	l'exécution de la première instruction : le segment bss se  
	résume alors aux variables locales de la fonction main().  
	La pile et le tas sont des zones variables.
Les autres informations  
	D'autres informations sont placées dans l'espace mémoire  
	du processus, comme les paramètres passés en ligne lors  
	de l'exécution du programme.  
	Suivant les systèmes d'exploitation, le système peut aussi  
	stocker différents renseignements, comme par exemple le  
	mode dans lequel doit s'exécuter le processus. Ces  
	renseignements se trouvent dans une structure qui se  
	nomme souvent Process Control Bloc (PCB).
Conclusion  
	L'espace mémoire d'un processus est donc divisé en deux  
	morceaux variables situés chacun à une extrémité de  
	l'espace. Ces morceaux sont eux-mêmes divisés en  
	plusieurs segments, certains de taille fixe situés aux  
	extrémités, d'autres de taille variable.  
	Suivant les systèmes d'exploitation, le tas et la pile  
	peuvent se trouver l'un en haut et l'autre en bas, ou  
	l'inverse.
## Organisation de la mémoire physique
## Pagination
La pagination constitue une approche permettant de  
réduire la fragmentation de la mémoire  
(fragmentation externe).  
L’espace des adresses logiques d’un processus est  
‘paginé’ :  
•Les pages sont indépendantes en terme d’adressage à  
l’intérieur de la mémoire et ne sont pas nécessairement  
contiguës  
•Le SE alloue la mémoire physique chaque fois que la  
nécessité de loger une page se présente.
![[Pasted image 20230315192203.png]]
![[Pasted image 20230315192222.png]]
Avantages et inconvénients:  
◼ Meilleure utilisation de la mémoire physique  
(programmes implantés par fragments, dans des pages  
non consécutives).  
◼ Possibilité de ne charger des pages que lorsqu'elles  
sont référencées (chargement à la demande).  
◼ Indépendance de l'espace virtuel et de la mémoire  
physique (mémoire virtuelle généralement plus grande).  
◼ Par contre, fragmentation interne (toutes les  
pages ne sont pas remplies).
## Pagination et Segmentation
![[Pasted image 20230315192255.png]]
## Segmentation
![[Pasted image 20230315192331.png]]
![[Pasted image 20230315192347.png]]
![[Pasted image 20230315192425.png]]
Malheureusement, l’allocations et la  
désallocations successives des segments crée  
également un problème de fragmentation :  
On va alors combiner segmentation et pagination :  
→ paginer les segments
## Segmentation et Pagination
La segmentation et la pagination sont deux notions  
différentes qui sont utilisées conjointement.  
La segmentation doit être vue comme une structuration  
de l'espace des adresses d'un processus, alors que la  
pagination doit être vue comme un moyen d'adaptation  
de la mémoire virtuelle à la mémoire réelle
## Mémoire virtuelle
![[Pasted image 20230315192500.png]]
![[Pasted image 20230315192514.png]]
![[Pasted image 20230315192527.png]]
![[Pasted image 20230315192549.png]]
Bit de validation et défaut de page  
Ne charger que les pages utiles à un instant :  
→ il faut pouvoir tester la présence d'une page en  
mémoire centrale :  
→ rôle du bit de validation  
→ si un processus cherche à accéder à une page non  
présente en mémoire centrale, il se produit un  
déroutement de défaut de page  
	le système d'exploitation lance une entrée/sortie disque  
	pour charger la page en mémoire dans une case libre  
		→ perte de performances !
![[Pasted image 20230315192649.png]]
![[Pasted image 20230315192804.png]]
Les pages d'un processus ne sont chargées en mémoire  
centrale que lorsque le processus y accède  
❑ Lorsqu'un processus accède à une page non présente en  
mémoire centrale, il se produit un défaut de page.  
La page manquante est alors chargée dans une case libre.  
❑Si aucune case n'est libre, le système utilise un algorithme de  
remplacement de page pour choisir une case à libérer.  
❑ L'écroulement est la situation pour laquelle un ou plusieurs  
processus passent plus de temps à paginer qu'à s'exécuter.
# gestion des fichiers
## Les concepts
### Le concept de fichier
La mémoire centrale est une mémoire volatile :  
→ il faut stocker les données devant être conservées au delà de l'arrêt  
de la machine sur un support de masse permanent  
→ l'unité de conservation sur le support de masse est le fichier  
exemple : il faut conserver les programmes du système d'exploitation
Les données dans le fichier sont organisées  
selon les besoins de l'utilisateur sous forme  
d'enregistrements (articles, records)  
→ Fichier logique  
Système de Gestion de Fichiers :  
▪ accès aux données du fichier  
▪ allocation des fichiers sur le support de masse  
→ Fichier physique
### Fichier Logique
Un fichier logique est un ensemble d'enregistrements, désigné par  
un nom et accessible via des fonctions d'accès.  
Type de donnée standard  
▪ Identifié par un nom  
Fonctions standards  
▪ Création / ouverture /  
fermeture / destruction  
▪ Ensemble d’enregistrements = fichier  
logique  
▪ Enregistrement = groupe de données de  
types divers
#### Fichier à mode d’accès séquentiel
![[Pasted image 20230321180800.png]]
#### Fichier à mode d’accès indexé (ou aléatoire)
![[Pasted image 20230321180848.png]]
#### Fichier à mode d’accès direct
![[Pasted image 20230321180913.png]]
### Fichier physique
![[Pasted image 20230321180930.png]]
#### Le bloc physique
Pour un meilleur compromis: temps d'accès et capacité de stockage  
certains SGF organisent l'espace du disque en blocs de secteurs  
Exemple : 1 bloc = 2 secteurs de 512 octets soit 1KO  
Les opérations de lecture et d'écriture du SGF se font bloc par bloc
![[Pasted image 20230321184544.png]]
#### Allocation de la mémoire
Les enregistrements logiques doivent être écrits dans les secteurs  
constituants les blocs  
→ il faut allouer les blocs physiques au fichier
![[Pasted image 20230321185112.png]]
#### Allocation contigüe
![[Pasted image 20230321185145.png]]
![[Pasted image 20230321185219.png]]
![[Pasted image 20230321185515.png]]
![[Pasted image 20230321185527.png]]
#### Allocation par zones
![[Pasted image 20230321185552.png]]
#### Allocation par bloc chainés
![[Pasted image 20230321185624.png]]
#### Allocation par bloc chainés – variante : FAT
![[Pasted image 20230321185647.png]]
#### Allocation indexée
→ Les adresses des blocs physiques constituant un fichier sont rangées dans une  
table appelée bloc d'index, elle même contenue dans un ou plusieurs blocs  
disque
![[Pasted image 20230321185720.png]]
#### Allocation indexée : solution UNIX
![[Pasted image 20230321185743.png]]
![[Pasted image 20230321185758.png]]
#### Allocation indexée : solution UNIX
![[Pasted image 20230321185826.png]]
![[systm exploit, concepts_230320_175532.pdf]]
#### Gestion de l’espace libre
Le système maintient une liste d'espace libre, qui mémorise tous les blocs disque  
libres (non alloués)  
Création/extension d'un fichier : recherche dans la liste d'espace libre de la  
quantité requise d'espace et allocation au fichier :  
▪ l'espace alloué est supprimé de la liste  
Destruction d'un fichier : l'espace libéré est intégré à la liste d'espace libre  
Il existe différentes représentations possibles de l'espace libre  
▪ vecteur de bits  
▪ liste chainée des blocs libres
#### Gestion de l’espace libre par vecteur de bits
![[Pasted image 20230321185930.png]]
#### Gestion de l’espace libre par liste chainée
![[Pasted image 20230321190001.png]]
#### Gestion de l’espace libre : FAT
![[Pasted image 20230321190019.png]]
### Correspondance, fichier logique / fichier physique
#### Désignation des fichiers : le répertoire
![[Pasted image 20230321190325.png]]
#### Structure des répertoires
![[Pasted image 20230321190353.png]]
![[Pasted image 20230321190403.png]]
![[Pasted image 20230321192543.png]]
#### Volume ou partition
![[Pasted image 20230321192607.png]]
#### Ex : partition FAT
![[Pasted image 20230321192633.png]]
#### Ex : partition FAT – répertoire racine
![[Pasted image 20230321192703.png]]
#### Ex : UNIX
![[Pasted image 20230321192723.png]]
![[Pasted image 20230321192737.png]]
## Réalisation des opérations
### Les commandes et les requêtes
Les commandes:  
• interface SGF utilisateurs  
• langage de commande ex: shell d'unix, commandes MS-DOS  
• Niveau des fichiers et non du contenu des fichiers
![[Pasted image 20230321192845.png]]
Les requêtes (appels systèmes) :  
• interface SGF logiciel  
• appel dans un programme aux fonctions du SGF (langage C, Java...)  
• niveau fichier et enregistrements
![[Pasted image 20230321192917.png]]
Les commandes du S.E. incluent un certain nombre de commandes SGF  
→ Langage de commandes  
	Quelques commandes du SGF:  
	• liste du répertoire (ls, dir)  
	• changement de répertoire (cd)  
	• création répertoire (mkdir)  
	• suppression répertoire (rmdir)  
	• suppression fichier (rm, del)  
	• modification d'attributs d'un fichier (chmod)  
	• changement de nom de fichier... (mv, ren)
![[Pasted image 20230321192950.png]]
Les requêtes sont des appels aux fonctions SGF dans un programme.  
Les requêtes permettent de modifier le contenu des fichiers  
Quelques requêtes du SGF:  
• ouverture fichier (open)  
• création de fichier (create)  
• fermeture fichier (close)  
Et  
• lecture d'enregistrement (read)  
• écriture d'enregistrement (write)
### Exemple sous Dos
wtf rien dans le cours ?
### Exemple sous UNIX
wtf rien dans le cours ?
## protection des fichiers
### a. Protection contre les dégâts physiques
Utilisation de la redondance interne :  
• L'information existe en double exemplaire : une version primaire, une version secondaire  
• Le système maintient la cohérence entre les deux versions  
exemple : MSDOS dispose de deux exemplaires de la FAT  
Redondance par sauvegarde périodique :  
• sauvegarde complète : la totalité des objets est dupliquée même si  
ils n'ont pas été modifiés  
• sauvegarde incrémentale : seuls les objets modifiés depuis la  
dernière sauvegarde sont dupliqués.
### b. Protection contre les accès inappropriés
Définition de droits d'accès  
– lecture (r), écriture (w), exécution (x), destruction ...  
A chaque fichier est associé une liste d'accès, spécifiant pour chaque  
utilisateur, les types d'accès qui lui sont autorisés
![[Pasted image 20230321193319.png]]
Ainsi, dans le monde UNIX, nous différencions les droits standards suivants : lecture (r), écriture (w),  
exécution (x).  
Ces droits sont appliqués à chaque fichiers et peuvent être modifiés via la commande « chmod », en  
indiquant les valeurs décimales de chaque droit + le nom du fichier. (ex: chmod 750 file.txt)  
Les droits peuvent être calculés de la manière suivante :
![[Pasted image 20230321193341.png]]
La liste d'accès peut être longue et difficile à gérer
• définition de groupes auxquels sont associés des droits  
• un utilisateur hérite des droits du groupe auxquels il appartient
![[Pasted image 20230321193409.png]]
#### Exemple Unix
![[Pasted image 20230321193434.png]]
# systèmes de fichiers-add
## Objectifs
## Les différents Système de Fichiers
## Les méta-données
## Les fonctions du SGF
## La mémoire cache
## Systèmes journalisés
## Les différents systèmes de fichiers
## FAT → File Allocation Table
### FAT - Structure
### FAT - Clusters
### FAT16 – Partitions
### FAT12 – Disquette
### FAT – Fragmentation
### FAT32 – Partitions
### FAT – Table
### FAT – Taille de la table
### FAT – Les répertoires
### FAT – Noms longs : VFAT
### FAT – Répertoire racine
### FAT – Avantages et inconvénients
### FAT – FAT16 / FAT32
## NTFS - New Technology File System
### NTFS - Volume
### NTFS – MFT : Master File Table
### NTFS – MFT
### NTFS – entrées MFT
### NTFS – attributs
### NTFS – MFT
### NTFS – Structure
### NTFS – log file
### NTFS – Files
### NTFS - Clusters
### NTFS – LCN / VCN
### NTFS – $DATA_RUN
### NTFS – permissions
### NTFS – conclusion
## EXT2 / EXT3 - Extended file system
### EXT2 / EXT3 - Bloc
### EXT2 / EXT3 - Structure
### EXT2 / EXT3 – Inodes / table des blocs
### EXT2 / EXT3 – Inodes / table des blocs
### EXT2 / EXT3 – Liens
### EXT2 / EXT3 – Liens physiques
### EXT2 / EXT3 – Liens symboliques
### EXT2 / EXT3 – amélioration EXT3
## TMPFS – Temporary File System
### TMPFS – Avantages / Inconvénients
## VMFS – Virtual Machine File System
## NFS – Network File System
### NFS – Conversion des systèmes
## Conclusions
# systèmes de fichiers-V3

