# ordonnancement
## Définition
### Le problème
• Quand doit-on stopper un processus s'exécutant sur un CPU ?  
• Quel processus va continuer sur ce CPU ?  
• Mêmes questions pour les threads d'un processus.  
• Que se passe t’il avec plusieurs processeurs ?
### Les objectifs
✓ Maximiser le taux d'occupation du processeur  
✓ Minimiser le temps de réponse des processus  
Critères d'évaluations de l’ordonnancement :  
• Temps d'attente des processus  
• Débit du processeur  
• Temps de réponse moyen  
• Temps de traitement d'un ensemble de processus
### Les critères d'ordonnancement
Il y aura normalement plusieurs processus dans la file prêt  
Quand le CPU devient disponible, lequel choisir?  
Critères généraux:  
• Bonne utilisation du CPU  
• Réponse rapide à l’usager
Il y a aussi des critères spécifiques d’ordonnancement :  
Utilisation UCT: pourcentage d’utilisation (à maximiser).  
Débit = Throughput: nombre de processus qui s’exécutent complètement dans l’unité  
de temps (à maximiser).  
Temps de rotation = turnaround: le temps pris par le processus de son arrivée à sa  
fin (à minimiser).  
Temps d’attente: attente dans la file prêt (somme de tout le temps passé en file prêt)  
(à minimiser).  
Temps de réponse (pour les systèmes interactifs): le temps entre une demande et la  
réponse (à minimiser).
Nous distinguons deux types d’ordonnancement (concerne l’ordonnancement a court  
terme) :  
• Les mécanismes non-préemptifs qui n’interrompent pas le fonctionnement d’un  
processus : seul l’attente sur une entrée/sortie (qui peut stopper le fonctionnement  
d’un processus) et la fin d’un processus peuvent provoquer l’appel de l’ordonnanceur.  
• Les mécanismes préemptifs qui peuvent interrompre le fonctionnement d’un  
processus ce qui suppose la mise en place d’un timer et des méthodes plus  
complexes de gestion des changements de contexte.
### ordonnanceur et répartiteur
obsidian://open?vault=1TI&file=ludo%2FObsidian-TI_github%2FTI%2FQ2%2FSyst%C3%A8mes%20d'exploitation%2FSyst%C3%A8mes%20d'exploitation%2C%20concepts
![[Pasted image 20230321125943.png]()]
![[Pasted image 20230321130008.png]]
### parallélisme réel et pseudo-parallélisme
![[Pasted image 20230321130037.png]]
## Les mécanismes
### Premier arrivé, premier servi FCFS (ou FIFO) sans ou avec réquisition
#### exemple
![[Pasted image 20230321130235.png]]
#### autre exemple
![[Pasted image 20230321130330.png]]
• Donc dans un sens FCFS favorise les  
processus tributaires du CPU et peut  
conduire à une très mauvaise utilisation des  
ressources tant du CPU que de  
périphériques.  
• Une possibilité: interrompre de temps en  
temps les processus tributaires du CPU pour  
permettre aux autres processus d’exécuter  
(préemption)
### Plus court d'abord
Ce mécanisme consiste à sélectionner le processus nécessitant le moins de temps  
d’exécution (le prochain Burst CPU le plus court). Il existe deux approches :  
• Non-préemptive ; le processus qui prend le contrôle de l’UC ne le quitte qu’à la fin de  
son exécution ou lorsqu’il est bloqué.  
• Préemptive : si un nouveau processus arrive dont la durée prévue est inférieure au  
temps restant d’exécution du processus en cours, ce nouveau processus obtient le  
contrôle du CPU (on parle alors de SRIF, Shortest Remaining Time First)
#### Exemple
![[Pasted image 20230321130423.png]]
![[Pasted image 20230321130445.png]]
![[Pasted image 20230321130502.png]]
#### Exercices 1
![[Pasted image 20230321130631.png]]
![[Pasted image 20230321130645.png]]
#### Exercice 2
![[Pasted image 20230321130719.png]]
![[Pasted image 20230321130730.png]]
![[Pasted image 20230321130745.png]]
![[Pasted image 20230321130757.png]]
![[Pasted image 20230321130809.png]]
![[Pasted image 20230321130822.png]]
![[Pasted image 20230321130833.png]]
![[Pasted image 20230321130843.png]]
### Par priorités constantes
Par priorités constantes  
• chaque processus reçoit une priorité  
• le processus de plus forte priorité est élu  
Avec ou sans réquisition (préemption)
![[Pasted image 20230321130924.png]]
#### Exercice3
![[Pasted image 20230321130948.png]]
![[Pasted image 20230321131002.png]]
### Par priorité : Rate Monotonic
![[Pasted image 20230321131102.png]]
### Par tourniquet (round robin)
• Ce mécanisme est particulièrement utilisé  
dans les systèmes à temps partagé. Le  
planificateur alloue à tour de rôle à chaque  
processus un quota de temps du CPU (10 –  
100 ms).  
• Le processus en cours peut s'interrompre  
pour des raisons internes (ex : accès a un  
périphérique, fin du processus, etc) ou  
parce que le quota de temps alloué s'est  
écoulé. Dans le second cas il est remis  
dans la queue des processus prêts.
#### exemple
![[Pasted image 20230321131130.png]]
#### autre exemple
![[Pasted image 20230321131148.png]]
### Par files de priorités de priorités constantes multiniveaux avec ou sans extinction de priorité
L’ordonnancement  
Les mécanismes  
• Chaque file est associée à un quantum de temps éventuellement différent  
• sans extinction : un processus garde toujours la même priorité  
• avec extinction : la priorité d'un processus décroit en fonction de son utilisation du cpu
![[Pasted image 20230321131303.png]]
![[Pasted image 20230321131323.png]]

### Ordonnancement : système LINUX

![[Pasted image 20230321131424.png]]
## ex de cette partie
![[Système exploit theorie_230310_135602.pdf]]

# gestion de la mémoire
## La fonction de mémorisation
Trois problèmes à résoudre vis-à-vis de la  
mémoire :  
❑Définir un espace d'adressage indépendant  
pour chaque processus  
❑Protéger les espaces d'adressages des processus  
entre eux  
❑Allouer de la mémoire physique à chaque espace  
d'adressage
## Le chargement dynamique en mémoire
![[Pasted image 20230315191402.png]]
![[Pasted image 20230315191426.png]]
## Le découpage de la mémoire
La mémoire centrale peut-être découpée de trois façons :  
◼ la segmentation : les programmes sont découpés en  
parcelles ayant des longueurs variables appelées  
«segments».  
◼ la pagination : elle consiste à diviser la mémoire en  
blocs, et les programmes en pages de longueur fixe.  
◼ une combinaison de segmentation et de pagination :  
certaines parties de la mémoires sont segmentées, les  
autres sont paginées.
## Organisation de la mémoire d’un processus
![[Pasted image 20230315191540.png]]
Le segment de code  
	Le segment de code est obtenu en copiant directement  
	en mémoire le segment de code du fichier exécutable.  
	Au cours de l'exécution du programme, la prochaine  
	instruction à exécuter est repérée par un pointeur  
	d'instruction.
Le segment de données  
	Au dessus du segment de code se trouve le segment  
	de données.  
	Ce segment est traditionnellement composé d'un  
	segment de données initialisées (data), qui est  
	directement copié à partir de l'exécutable, et d'un  
	segment de données non initialisées (bss pour block  
	storage segment) qui est créé dynamiquement.
![[Pasted image 20230315191655.png]]
	Les données initialisées correspondent à toutes les  
	variables globales et statiques initialisées des programmes  
	C. Les données non initialisées correspondent aux  
	variables globales et statiques non initialisées.  
	Le segment de données peut être agrandi ou réduit au  
	cours de l'exécution pour permettre d'y placer des  
	données. Néanmoins, il est habituel de considérer que ce  
	segment est fixe et correspond à celui obtenu avant  
	l'exécution de la première instruction : le segment bss se  
	résume alors aux variables locales de la fonction main().  
	La pile et le tas sont des zones variables.
Les autres informations  
	D'autres informations sont placées dans l'espace mémoire  
	du processus, comme les paramètres passés en ligne lors  
	de l'exécution du programme.  
	Suivant les systèmes d'exploitation, le système peut aussi  
	stocker différents renseignements, comme par exemple le  
	mode dans lequel doit s'exécuter le processus. Ces  
	renseignements se trouvent dans une structure qui se  
	nomme souvent Process Control Bloc (PCB).
Conclusion  
	L'espace mémoire d'un processus est donc divisé en deux  
	morceaux variables situés chacun à une extrémité de  
	l'espace. Ces morceaux sont eux-mêmes divisés en  
	plusieurs segments, certains de taille fixe situés aux  
	extrémités, d'autres de taille variable.  
	Suivant les systèmes d'exploitation, le tas et la pile  
	peuvent se trouver l'un en haut et l'autre en bas, ou  
	l'inverse.
## Organisation de la mémoire physique
## Pagination
La pagination constitue une approche permettant de  
réduire la fragmentation de la mémoire  
(fragmentation externe).  
L’espace des adresses logiques d’un processus est  
‘paginé’ :  
•Les pages sont indépendantes en terme d’adressage à  
l’intérieur de la mémoire et ne sont pas nécessairement  
contiguës  
•Le SE alloue la mémoire physique chaque fois que la  
nécessité de loger une page se présente.
![[Pasted image 20230315192203.png]]
![[Pasted image 20230315192222.png]]
Avantages et inconvénients:  
◼ Meilleure utilisation de la mémoire physique  
(programmes implantés par fragments, dans des pages  
non consécutives).  
◼ Possibilité de ne charger des pages que lorsqu'elles  
sont référencées (chargement à la demande).  
◼ Indépendance de l'espace virtuel et de la mémoire  
physique (mémoire virtuelle généralement plus grande).  
◼ Par contre, fragmentation interne (toutes les  
pages ne sont pas remplies).
## Pagination et Segmentation
![[Pasted image 20230315192255.png]]
## Segmentation
![[Pasted image 20230315192331.png]]
![[Pasted image 20230315192347.png]]
![[Pasted image 20230315192425.png]]
Malheureusement, l’allocations et la  
désallocations successives des segments crée  
également un problème de fragmentation :  
On va alors combiner segmentation et pagination :  
→ paginer les segments
## Segmentation et Pagination
La segmentation et la pagination sont deux notions  
différentes qui sont utilisées conjointement.  
La segmentation doit être vue comme une structuration  
de l'espace des adresses d'un processus, alors que la  
pagination doit être vue comme un moyen d'adaptation  
de la mémoire virtuelle à la mémoire réelle
## Mémoire virtuelle
![[Pasted image 20230315192500.png]]
![[Pasted image 20230315192514.png]]
![[Pasted image 20230315192527.png]]
![[Pasted image 20230315192549.png]]
Bit de validation et défaut de page  
Ne charger que les pages utiles à un instant :  
→ il faut pouvoir tester la présence d'une page en  
mémoire centrale :  
→ rôle du bit de validation  
→ si un processus cherche à accéder à une page non  
présente en mémoire centrale, il se produit un  
déroutement de défaut de page  
	le système d'exploitation lance une entrée/sortie disque  
	pour charger la page en mémoire dans une case libre  
		→ perte de performances !
![[Pasted image 20230315192649.png]]
![[Pasted image 20230315192804.png]]
Les pages d'un processus ne sont chargées en mémoire  
centrale que lorsque le processus y accède  
❑ Lorsqu'un processus accède à une page non présente en  
mémoire centrale, il se produit un défaut de page.  
La page manquante est alors chargée dans une case libre.  
❑Si aucune case n'est libre, le système utilise un algorithme de  
remplacement de page pour choisir une case à libérer.  
❑ L'écroulement est la situation pour laquelle un ou plusieurs  
processus passent plus de temps à paginer qu'à s'exécuter.
# gestion des fichiers
## Les concepts
### Le concept de fichier
La mémoire centrale est une mémoire volatile :  
→ il faut stocker les données devant être conservées au delà de l'arrêt  
de la machine sur un support de masse permanent  
→ l'unité de conservation sur le support de masse est le fichier  
exemple : il faut conserver les programmes du système d'exploitation
Les données dans le fichier sont organisées  
selon les besoins de l'utilisateur sous forme  
d'enregistrements (articles, records)  
→ Fichier logique  
Système de Gestion de Fichiers :  
▪ accès aux données du fichier  
▪ allocation des fichiers sur le support de masse  
→ Fichier physique
### Fichier Logique
Un fichier logique est un ensemble d'enregistrements, désigné par  
un nom et accessible via des fonctions d'accès.  
Type de donnée standard  
▪ Identifié par un nom  
Fonctions standards  
▪ Création / ouverture /  
fermeture / destruction  
▪ Ensemble d’enregistrements = fichier  
logique  
▪ Enregistrement = groupe de données de  
types divers
#### Fichier à mode d’accès séquentiel
![[Pasted image 20230321180800.png]]
#### Fichier à mode d’accès indexé (ou aléatoire)
![[Pasted image 20230321180848.png]]
#### Fichier à mode d’accès direct
![[Pasted image 20230321180913.png]]
### Fichier physique
![[Pasted image 20230321180930.png]]
#### Le bloc physique
Pour un meilleur compromis: temps d'accès et capacité de stockage  
certains SGF organisent l'espace du disque en blocs de secteurs  
Exemple : 1 bloc = 2 secteurs de 512 octets soit 1KO  
Les opérations de lecture et d'écriture du SGF se font bloc par bloc
![[Pasted image 20230321184544.png]]
#### Allocation de la mémoire
Les enregistrements logiques doivent être écrits dans les secteurs  
constituants les blocs  
→ il faut allouer les blocs physiques au fichier
![[Pasted image 20230321185112.png]]
#### Allocation contigüe
![[Pasted image 20230321185145.png]]
![[Pasted image 20230321185219.png]]
![[Pasted image 20230321185515.png]]
![[Pasted image 20230321185527.png]]
#### Allocation par zones
![[Pasted image 20230321185552.png]]
#### Allocation par bloc chainés
![[Pasted image 20230321185624.png]]
#### Allocation par bloc chainés – variante : FAT
![[Pasted image 20230321185647.png]]
#### Allocation indexée
→ Les adresses des blocs physiques constituant un fichier sont rangées dans une  
table appelée bloc d'index, elle même contenue dans un ou plusieurs blocs  
disque
![[Pasted image 20230321185720.png]]
#### Allocation indexée : solution UNIX
![[Pasted image 20230321185743.png]]
![[Pasted image 20230321185758.png]]
#### Allocation indexée : solution UNIX
![[Pasted image 20230321185826.png]]
![[systm exploit, concepts_230320_175532.pdf]]
#### Gestion de l’espace libre
Le système maintient une liste d'espace libre, qui mémorise tous les blocs disque  
libres (non alloués)  
Création/extension d'un fichier : recherche dans la liste d'espace libre de la  
quantité requise d'espace et allocation au fichier :  
▪ l'espace alloué est supprimé de la liste  
Destruction d'un fichier : l'espace libéré est intégré à la liste d'espace libre  
Il existe différentes représentations possibles de l'espace libre  
▪ vecteur de bits  
▪ liste chainée des blocs libres
#### Gestion de l’espace libre par vecteur de bits
![[Pasted image 20230321185930.png]]
#### Gestion de l’espace libre par liste chainée
![[Pasted image 20230321190001.png]]
#### Gestion de l’espace libre : FAT
![[Pasted image 20230321190019.png]]
### Correspondance, fichier logique / fichier physique
#### Désignation des fichiers : le répertoire
![[Pasted image 20230321190325.png]]
#### Structure des répertoires
![[Pasted image 20230321190353.png]]
![[Pasted image 20230321190403.png]]
![[Pasted image 20230321192543.png]]
#### Volume ou partition
![[Pasted image 20230321192607.png]]
#### Ex : partition FAT
![[Pasted image 20230321192633.png]]
#### Ex : partition FAT – répertoire racine
![[Pasted image 20230321192703.png]]
#### Ex : UNIX
![[Pasted image 20230321192723.png]]
![[Pasted image 20230321192737.png]]
## Réalisation des opérations
### Les commandes et les requêtes
Les commandes:  
• interface SGF utilisateurs  
• langage de commande ex: shell d'unix, commandes MS-DOS  
• Niveau des fichiers et non du contenu des fichiers
![[Pasted image 20230321192845.png]]
Les requêtes (appels systèmes) :  
• interface SGF logiciel  
• appel dans un programme aux fonctions du SGF (langage C, Java...)  
• niveau fichier et enregistrements
![[Pasted image 20230321192917.png]]
Les commandes du S.E. incluent un certain nombre de commandes SGF  
→ Langage de commandes  
	Quelques commandes du SGF:  
	• liste du répertoire (ls, dir)  
	• changement de répertoire (cd)  
	• création répertoire (mkdir)  
	• suppression répertoire (rmdir)  
	• suppression fichier (rm, del)  
	• modification d'attributs d'un fichier (chmod)  
	• changement de nom de fichier... (mv, ren)
![[Pasted image 20230321192950.png]]
Les requêtes sont des appels aux fonctions SGF dans un programme.  
Les requêtes permettent de modifier le contenu des fichiers  
Quelques requêtes du SGF:  
• ouverture fichier (open)  
• création de fichier (create)  
• fermeture fichier (close)  
Et  
• lecture d'enregistrement (read)  
• écriture d'enregistrement (write)
### Exemple sous Dos
wtf rien dans le cours ?
### Exemple sous UNIX
wtf rien dans le cours ?
## protection des fichiers
### a. Protection contre les dégâts physiques
Utilisation de la redondance interne :  
• L'information existe en double exemplaire : une version primaire, une version secondaire  
• Le système maintient la cohérence entre les deux versions  
exemple : MSDOS dispose de deux exemplaires de la FAT  
Redondance par sauvegarde périodique :  
• sauvegarde complète : la totalité des objets est dupliquée même si  
ils n'ont pas été modifiés  
• sauvegarde incrémentale : seuls les objets modifiés depuis la  
dernière sauvegarde sont dupliqués.
### b. Protection contre les accès inappropriés
Définition de droits d'accès  
– lecture (r), écriture (w), exécution (x), destruction ...  
A chaque fichier est associé une liste d'accès, spécifiant pour chaque  
utilisateur, les types d'accès qui lui sont autorisés
![[Pasted image 20230321193319.png]]
Ainsi, dans le monde UNIX, nous différencions les droits standards suivants : lecture (r), écriture (w),  
exécution (x).  
Ces droits sont appliqués à chaque fichiers et peuvent être modifiés via la commande « chmod », en  
indiquant les valeurs décimales de chaque droit + le nom du fichier. (ex: chmod 750 file.txt)  
Les droits peuvent être calculés de la manière suivante :
![[Pasted image 20230321193341.png]]
La liste d'accès peut être longue et difficile à gérer
• définition de groupes auxquels sont associés des droits  
• un utilisateur hérite des droits du groupe auxquels il appartient
![[Pasted image 20230321193409.png]]
#### Exemple Unix
![[Pasted image 20230321193434.png]]
# systèmes de fichiers-V3
## Objectifs
![[Pasted image 20230414114821.png]]
## Les différents Système de Fichiers
•Système de fichiers ?
	•Stockage et organisations de fichiers sur support
• Principe de stockage
	• FAT : Association nom/contenu : Table
	• Unix et i-node
	• NTFS : Base de données
• Les systèmes de fichiers les plus courants sont:
	FAT
	NTFS
	Ext2-3-4
	TMPFS
	VMFS
	NFS
	Et bien d’autres encore…
## Les méta-données
• Description du fichier (exemple pour Unix/Linux)
	Droits d’accès
	Date de dernier accès de modification (données et
	métadonnées
	Propriétaire et groupe propriétaire
	Taille du fichier
	Nombre d’autres i-nodes (liens) pointant vers le fichier
	Nombre de blocs utilisés par le fichier
	Type de fichier (simple, lien symbolique, répertoire,
	périphériqe, etc)
	Pointeur vers le contenu
## Les fonctions du SGF
Manipulation des fichiers
Allocation de la place sur mémoires secondaires
Localisation des fichiers
Sécurité et contrôle des fichiers
## La mémoire cache
Accès disque de l'ordre de 1 000 000 fois plus lents que accès mémoire
• Il faut minimiser le nombre d'accès disque
• Pour réduire les accès disques :
	- Bufferiser les commandes d'écriture et de lecture
	- Éviter les écritures inutiles
• Avantages :
	- Réduit le trafic disque
	- Protège contre certaines écritures ”concurrentes”
• Désavantages :
	- Problème lors d'un crash système
	- Recopie vers ou à partir du cache pour toute entrée-sortie
• Le statut d'un bloc cache est une combinaison des
états suivants :
	- verrouillé → l'accès est réservé à un processus
	- valide → les données contenues dans le bloc sont valides
	-  "à écrire" → les données du bloc doivent être écrites sur disque avant de ré-allouer le bloc
	- Actif → le noyau est en train d'écrire/lire le bloc sur le disque
	- Attendu → un processus attend la libération du bloc
## Systèmes journalisés
Problème à résoudre lié au cache :
	- À cause du cache, en cas d'interruption brutale, les
	informations devant être stockées sur le disque peuvent être
	perdues.
	- Ce problème est valable aussi bien pour les opérations
	d'écriture que d'effacement.
	- Nécessité de vérifier l'intégrité du disque en entier avec
	l'utilitaire fsck lors d'un crash.
	- Cette procédure peut être très longue.
	- Pour corriger ce problème → nouveau type de système de
	fichiers utilisant un autre principe de cache.
	- Réductions des opérations d'entrée/sortie sous la forme de
	transaction.
	- Une trace complète de toutes les transactions est conservée
	sous la forme d'un journal.
	- Lors d'un crash système il n'est plus nécessaire de vérifier
	l'intégralité du disque car nous savons quelles données était
	présentes ou non lors de l'incident.
	• Cohérence
	• Fichier de modification
	• Tolérance aux pannes et intégrité
	![[Pasted image 20230414115735.png]]
## Les différents systèmes de fichiers
Dans ce chapitre, nous allons expliquer les différents SF suivants :
	❑ FAT (File Allocation Table) de Microsoft
	❑ NTFS (New Technology File System) de Microsoft
	❑ Ext2-3-4 (Extended file system) utilisé dans le monde UNIX
	❑ TMPFS (Temporary File System) utilisé dans l’embarqué
	❑ VMFS (Virtual Machine File System) utilisé dans les outils de virtualisation
	❑ NFS (Network File System) utilisé sous Linux pour le partage réseau
	❑ Et bien d’autres encore…
## FAT → File Allocation Table
• Système de fichiers de DOS
• Clusters → Blocs (groupe de secteurs)
• Index qui liste le contenu du disque
	- Liste chaînée (une table) indiquant l'état de chaque cluster
	bloc)
	- Permet de connaître l'emplacement des fichiers sur le disque
	- Conserve la structure du fichier en créant des liens vers les
	blocs constitutifs du fichier (un bloc contient des data +
	l’adresse du block suivant )
• Plusieurs versions :
	- FAT12 (12 bits)
	- FAT16/vfat (16 bits)
	- FAT32 (28/32 bits)
• Conçu par Microsoft en 1977 (Bill Gates)
• Destiné aux 1ère disquettes : moins d'1Mb
• FAT d'une disquette de 1.44 Mb ne fait que 4.5 Ko
### FAT - Structure
![[Pasted image 20230414120103.png]]
Boot sector : métadonnées du système de fichiers
FAT : index
Répertoire racine (FAT16)
Clusters : blocs des fichiers et répertoires
### FAT - Clusters
![[Pasted image 20230414120135.png]]
• La taille d'un cluster est défini au formatage
• Un cluster est égal à n secteurs (512 bytes)
• n est une puissance de 2
### FAT16 – Partitions
16 bits maximum pour adresser les clusters
Le nombre max de clusters est 216 = 65536 clusters
La taille d'un cluster est 2n * 512 byte contigus
Taille cluster augmente → taille partition augmente
Taille max partition = nbr clusters * taille cluster
	- Exemple :
	- Cluster de 1Kb → taille max partition FAT16 est 64Mb
	- Cluster de 10Kb → taille max partition FAT16 est 640Mb
	- Cluster de 32Kb → taille max partition FAT16 est 2Gb
### FAT12 – Disquette
• Message après avoir formaté une disquette 1,44Mb :
![[Pasted image 20230414121024.png]]
Un cluster → 512 octets (un secteur)
La taille de la disquette est de 1.457.664 octets
Nbre de cluster = 1.457.664 / 512 = 2.847 clusters
Avec 12 bits, on peut encoder 212 = 4096 clusters
### FAT – Fragmentation
• Un fichier occupe un nombre entier de clusters
• Exemple :
	Cluster de 8 secteurs → 8 * 512 octets = 4096 octets
	Si un fichier est composé de un caractère (1 octet)
	La place inutilisée dans le cluster est 4096 – 1 = 4095 octets
- Peux poser des problème d'espace avec beaucoup de petits fichiers et des clusters de grande taille
### FAT32 – Partitions
- 32 bits pour les entrées de la FAT
- Mais 4 bits sont réservés
- Le nbre max de clusters est 228 = 268435456 clusters
- La FAT32 peut contenir beaucoup plus de clusters que la FAT16 → limitation de la fragmentation
- Exemple :
	Une partition de 2Gb
	Clusters de 4Kb avec le système FAT32
	Clusters de 32Kb en FAT16
	Diminution de l'espace gaspillé par un facteur 8
### FAT – Table
• Index contenant une entrée par cluster de la partition
• Décrit le chaînage des clusters par fichier
• Chaque entrée contient le numéro du cluster suivant
• Des valeurs particulières indiquent la fin de fichier
![[Pasted image 20230414121621.png]]
• Valeurs réservées :
![[Pasted image 20230414121711.png]]
### FAT – Taille de la table
• nombre entrées FAT = taille partition / taille clusters
• taille FAT = nombre entrées FAT * taille entrée FAT
• Exemple :
	Volume FAT32 de 500Gb
	Cluster de 4Kb
	→ taille de la table FAT = 500Mb
	avec des clusters de 16Kb on réduit à 125Mb
- Taille max de d'une table FAT16 est 128Kb
- Une table FAT32 peut devenir très grosse
- Elle est chargée en RAM au démarrage du système
- Un grand volume FAT ralentit le démarrage du système
### FAT – Les répertoires
• Une entrée d'un répertoire contient 32 octets et est
constituée comme suit:
	- Le nom du fichier → 8 caractères avant le point et 3 après (8.3)
	-  Le nom doit commencer par une lettre et est insensible à la casse
	-  Des d'attributs : ARCHIVE, READ_ONLY, HIDDEN, SYSTEM, DIRECTORY, VOLUME_ID
	- L'heure et la date de dernière modification
	- Le numéro du premier cluster
	- La longueur utile en octet
	- De plus 10 octets sont inutilisés
![[Pasted image 20230414122042.png]]
### FAT – Noms longs : VFAT
• VFAT → Virtual FAT
• Possibilité de nom de 255 caractères
• Plusieurs entrées répertoire sont créées :
	- un alias en 8.3 pour les anciennes versions DOS
	- le nom complet est ajouté sur plusieurs entrées
	- chaque nouvelle entrée permet 13 caractères de plus
	- jusqu’à 20 de ces entrées peuvent être enchaînées (8.3+19*13)
• Entrée marquée ATTR_LONG_NAME
	ATTR_LONG_NAME = READ_ONLY + HIDDEN + SYSTEM + VOLUME_ID
• DOS ne comprend pas ATTR_LONG_NAME → compatibilité ascendante
### FAT – Répertoire racine
![[Pasted image 20230414122450.png]]
• En FAT16
	- 512 entrées
	- emplacement fixe
	- allocation contiguë
• Lors de nom long, moins d'entrées sont possibles
	- 24 entrées si on utilise des noms de 255 caractères (512 / 21)
• En FAT32 c'est une chaîne de clusters ordinaire
	- permet de le positionner à un endroit quelconque du disque restrictions sur le nombre de répertoires racine abolies
### FAT – Avantages et inconvénients
Simple et connu par beaucoup d'OS
Taille des fichiers limitée à 4Gb
Pas de gestion d’attributs pour la protection d’accès
Pas adapté aux grandes partitions
Fragmentation des fichiers (surtout FAT16)
### FAT – FAT16 / FAT32
• FAT16 :
	- MS-DOS, Windows 95, Windows 98, Windows NT, Windows 2000 et quelques OS UNIX peuvent utiliser FAT16
	- Beaucoup d'outils existent en cas de corruption
	- Rapide et efficace pour des volumes jusqu'à 256Mb
	- 512 entrées maximum à la racine (moins avec noms longs)
	- la taille maximale d'un volume est de 4Gb (cluster de 64Kb)
	- perte d'espace lorsque la taille des clusters est plus grand
	32 – 1 = 4Gb
	- la taille maximale d'un fichier est de 2^32 – 1 = 4Gb
• FAT32 :
- meilleure allocation d'espace disque
- le répertoire racine étant une chaîne de cluster standard, il n'y a plus de restriction sur le nombre d'entrées
- plus robuste (ex : backup des structures de données critiques)
- plus lent au chargement (table plus grande)
- la taille maximale d'un volume est de 16Tb (cluster de 64Kb)
- la taille maximale d'un fichier est de 2^32 – 1 = 4Gb
## NTFS - New Technology File System
Développé par Microsoft
Natif de Windows NT
Successeur du système de fichiers FAT
Réponse aux demandes système multi-utilisateurs
Améliore les performances, la fiabilité et l'utilisation
de l'espace disque (16Tb)
### NTFS - Volume
La structure NTFS commence par un volume
Un volume correspond à une partition logique
Un disque peut contenir plusieurs volumes
Plusieurs disques peuvent être inclus dans un volume
Les volumes sont indépendants les uns des autres
Un volume NTFS ne contient pas de partitions
spécifiques, tout est « fichiers »
![[Pasted image 20230414123243.png]]
![[Pasted image 20230414123316.png]]
### NTFS – MFT : Master File Table
• Fichier des descripteurs de fichiers
• Toutes les données de structure, métadonnées,... sont contenues dans des fichiers
• Relocalisation facile des fichiers en cas de corruption disque
• Une entrée par fichier, incluant la MFT elle-même
![[Pasted image 20230414123414.png]]
• La taille d'une entrée est de 1Kb
• Les fichiers de métadonnées (pour construire le système de fichier) commence par un  $ 
- Par exemple : le fichier contenant la MFT est $Mft
![[Pasted image 20230414123544.png]]
### NTFS – MFT
![[Pasted image 20230414123602.png]]
### NTFS – entrées MFT
• Collection d'attributs
- Nom de fichier
- Informations d’horodatage
- ...
• Chaque attribut a une longueur variable
• Attributs résidents
- description entièrement contenue dans l’enregistrement
• Attributs non-résidents
- description non entièrement contenue dans l’enregistrement
![[Pasted image 20230414123741.png]]
### NTFS – attributs
• Chaque attribut a une longueur variable qu'il annonce par un en-tête
• 3 attributs et une marque de fin
• Attribut $FILE_NAME (résident)
- Plusieurs possible (nom NTFS, nom DOS)
• Attribut STANDARD INFORMATION
- résident
- Dates : création, modification, accès
- Permissions DOS
- ID propriétaire
- ...
![[Pasted image 20230414123938.png]]
### NTFS – MFT
• Un fichier ajouté → une entrée ajoutée → MFT grandit
• Un fichier effacé → entrée marquée comme libre
• Un entrée libre peut être réutilisée mais l'espace disque utilisé par l'entrée n'est pas libérée
• La taille de la MFT ne diminue jamais
### NTFS – Structure
• $Boot
	- taille secteur, nb secteurs, nb secteurs par cluster, nb clusters par enregistrement MFT, LCN du premier cluster des MFT et MFTMirr...
• une zone « réservée » : buffer MFT pour $Mft
• les espaces fichiers et répertoires
• le fichier $MFTMirr
![[Pasted image 20230414124059.png]]
### NTFS – log file
• Fichier $LogFile
• Utilisé pour enregistrer toutes les opérations sur la structure du volume NTFS (ex : copy)
• Sert à récupérer le volume après une panne système
### NTFS – Files
• Attribut $DATA
- résident pour un "petit fichier", non résident pour un "grand fichier"
- Pour un petit répertoire, l'index des fichiers et sous-répertoires est contenu directement dans l'attribut
- Pour un fichier qui serait trop grand pour l'entrée MFT (1Kb), les données ne seront pas résidentes et seulement les informations pour localiser les données seront dans la MFT
![[Pasted image 20230414124239.png]]
![[Pasted image 20230414124253.png]]
### NTFS - Clusters
![[Pasted image 20230414124310.png]]
La taille d'un cluster est défini au formatage
Un cluster est égal à n secteurs (512 bytes)
n est une puissance de 2
Les clusters sont numérotés à partir de 0
Le cluster 0 commence au secteur 0
### NTFS – LCN / VCN
• LCN
	- L'emplacement physique sur le disque est référencé par le « Logical Cluster Number »
	- Les LCNs sont la numérotation des clusters du début à la fin du volume
	- Pour convertir le LCN en adresse physique, il suffit de multiplier le LCN par la taille d'un cluster
• VCN
- L'emplacement des données dans un fichier est référencé par le « Virtual Cluster Number»
- Les VCNs ne sont pas nécessairement contigus
- Tout fichier commence par le VCN 0
### NTFS – $DATA_RUN
• Fichier non fragmenté:
	• 12 07 56 34 00
		• 1h (4bits) – 1 octets pour la longueur
		• 2h (4bits) – 2 octets pour le décalage
		• 07h – La longueur
		• 5634h – le décalage absolu
		• 00h – fin des RUN
	• Les données sont contenues sur 7 clusters à partir du LCN 5634h
	• 13 18 56 34 11 00
		• 1h (4bits) – 1 octets pour la longueur
		• 3h (4bits) – 3 octets pour le décalage
		• 18h – La longueur
		• 563411h – le décalage absolu
		• 00h – fin des RUN
	• Les données sont contenues sur 18h clusters à partir du LCN 536411h
	• 13 38 34 25 73 23 01 14 02 11 E5 00
	• Run1
		• 1 octets pour la longueur - 3 octets pour le décalage
		• 38h – La longueur
		• 342573h – le décalage absolu
	• Run 2
	• 2 octets pour la longueur - 3 octets pour le décalage
		• 0114h – La longueur
		• 0211E5h – le décalage relatif
	• Les données sont contenues sur 38h (56) clusters à partir du LCN
	342573h et 114h (276) clusters depuis le LCN 342573h + 0211E5h
### NTFS – permissions
• ACL : Access Control List
	• Les autorisations NTFS définissent :
	- qui peut accéder à un fichier/répertoire
	- quelles opérations lui sont permises
• Les permissions s'appliquent :
	- par fichier/répertoire
	- pour des opérations spécifiques (parcourir, lire, écrire, lire et exécuter, modifier, contrôle total)
	- à des utilisateurs ou groupes d’utilisateurs
![[Pasted image 20230414124817.png]]
• Les ACL sont stockées dans le fichier système $Secure
• Quelques règles :
	- le refus l’emporte sur les autres autorisations
	- les autorisations sont cumulatives (pour un utilisateur membre de différents groupes)
	- les autorisations sont héritées du répertoire parent mais les autorisations explicites priment sur ces dernières
• unix utilise par défaut un système d’ACL plus simple :
	- ACL’s de taille fixe - user, group, others
### NTFS – conclusion
• Par rapport à FAT32
	- évolution vers de grands volumes (16Tb)
	- sécurité (permissions)
	- rapidité au démarrage (comparé à FAT)
	- fiabilité (redondance, emplacement fichiers système, journalisation)
	- sujet à fragmentation interne
	- sujet à la fragmentation des fichiers
	- sujet à dégradation des performances si MFT fragmentée
## EXT2 / EXT3 - Extended file system
• Extended file system ou ext est créé en avril 1992
• Premier système de fichiers spécifiquement pour Linux
• ext2
	- développé en 1993
	- limité (2 Tb)
• ext3
	- journalisation
• ext4
	- supporte jusqu'au Pb (1015)
### EXT2 / EXT3 - Bloc
• Bloc : plus petite unité qui peut être allouée
• La taille des blocs est un multiple de la taille d'un secteur
• Chaque bloc peut être alloué ou libre
• Un bloc peut être découpé en fragments
	- il peut contenir les derniers fragments de plusieurs fichiers
	- la taille des fragments dépend de celle des blocs
### EXT2 / EXT3 - Structure
• Boot: contient le programme de démarrage
• Les blocs sont organisés en groupes de blocs
• Groupes de blocs :
	- Super-bloc
	- Descripteurs du groupe
	- Bitmap des blocs
	- Bitmap des i-nodes
	- Tables des i-nodes
	- Blocs de données
![[Pasted image 20230414125543.png]]
• Le superbloc
	- contient des informations essentielles
	- nombre d’inodes libres
	- emplacement de la table des inodes
	- ...
	- répliquée au début de chaque groupe de blocs dont le numéro est une puissance de 3, 5 ou 7
• La table de description des blocs
	- elle commence dans le bloc 1
	- contient les informations des blocs du groupe
• Un bloc est utilisé pour le bitmap des blocs
	- chaque bit à 0 correspond à un bloc « unallocated » dans le groupe
	- chaque bit à 1 correspond un bloc « allocated »
• Un bloc est utilisé pour le bitmap des inodes
	- même rôle pour les i-nœuds libres ou alloués
![[Pasted image 20230414125812.png]]
• Ces deux blocs sont utilisés lors de la recherche d'un emplacement libre pour la création d'un nouvel i-nœud ou de l'allocation d'un nouveau bloc à un fichier
• La table des Inodes
	- contient les inodes du groupe
• Les blocs de données (plus grande partie)
### EXT2 / EXT3 – Inodes / table des blocs
• Contient des pointeurs vers les blocs d'un fichier
• Les blocs qui constituent un fichier ne sont pas forcément contigus
• Chaque fichier est décrit par un i-noeud pour retrouver tous les fragments
• Un i-noeuds comporte en général 15 entrées
![[Pasted image 20230414125941.png]]
![[Pasted image 20230414130032.png]]
• Les entrées 0 à 11 pointent directement sur le bloc de données correspondant
	- Si un bloc fait 1024 octets, l'accès est direct pour tous les fichiers de taille inférieure à 12 x 1024 octets (12 Ko)
• L'entrée 12 pointe sur un bloc qui contient une table de blocs
	- cette table contient 256 entrées
	-  tailles de fichiers de 12 Ko + 256 * 1 Ko = 268 Ko
• L'entrée 13 permet une double indirection
	- les 256 blocs accessibles par la première indirection sont eux-mêmes des
	tables de blocs
	- la taille maximale de tels fichiers est alors de
	12 Ko + 256 * 1 Ko + 256 * 256 * 1 Ko = 65804 Ko
• L'entrée 14 permet une triple indirection
	- La taille maximale de tels fichiers est alors de
	12 Ko + 256 * 1 Ko + 256 * 256 * 1 Ko + 256 * 256 * 256 * 1 Ko
	= 16843020 Ko, soit plus de 16 Go
![[Pasted image 20230414130308.png]]
### EXT2 / EXT3 – Liens
![[Pasted image 20230414130328.png]]
### EXT2 / EXT3 – Liens physiques
- Chaque entrée d'un répertoire pointe sur un fichier
- Plusieurs entrées peuvent pointer vers un i-nœud
- Possibilité d'accéder au fichier par plusieurs chemins
- Ce sont des liens physiques (hard links)
- Suppression d'un fichier possible quand le nombre de liens physiques devient nul
### EXT2 / EXT3 – Liens symboliques
• Un lien symbolique est lui-même un fichier
• Le(s) bloc(s) de données contien(nen)t seulement le nom du fichier sur lequel il pointe, avec son chemin d'accès
• Un lien symbolique peut consommer plus d'espace disque qu'un lien physique
	- une entrée de la table des i-nœuds + le bloc qui contient le nom du
	fichier cible
### EXT2 / EXT3 – amélioration EXT3
• Journalisation (plus besoin de fsck)
• EXT2 peut être converti en EXT3 sans formatage, la seule modification à ajouter étant le journal
![[Pasted image 20230414130522.png]]
![[Pasted image 20230414130548.png]]
## TMPFS – Temporary File System
• Implémenté directement dans le noyau Linux depuis la version 2.6
• Apparaît comme un système de fichier
• Tout est stocké en mémoire
• Ce système de fichier est très utilisé dans les systèmes embarqués (à mémoire flash) afin de limiter les écritures sur le support pour ainsi augmenter sa durée de vie
### TMPFS – Avantages / Inconvénients
- Tous les fichiers sont effacés à chaque arrêt du système
- Vitesse d'accès aux fichiers accrue
- Économie de consommation électrique.
- Baisse de l'usure des disques
- Si la RAM est pleine → partition "swap"
- Un tmpfs de 1 GO ne prendra 1 GO de place dans la RAM que s'il est plein, il n'utilise que la place des fichiers qu'il contient
## VMFS – Virtual Machine File System
• Conçu spécifiquement pour la virtualisation
• Les systèmes de fichiers classiques ne permettent qu’à un seul serveur d’accéder à un système de fichier
• VMFS utilise le stockage partagé afin d’autoriser simultanément plusieurs hôtes à écrire et lire des données sur le même stockage
![[Pasted image 20230414130738.png]]
## NFS – Network File System
• Développé par Sun Microsystems en 1984
• Protocole qui permet d'accéder à un système de fichiers à distance par le réseau
• Pris en charge par tous les systèmes Unix
![[Pasted image 20230414130811.png]]
### NFS – Conversion des systèmes
Parmi les différents systèmes de fichiers abordés, il est (parfois)
possible de
convertir un SF vers un autre SF, c’est-à-dire utiliser un SF sans formater.
Ainsi donc, il est possible :
	➢ de convertir un SF en FAT32 vers NTFS via la commande « convert »
	➢ de convertir un SF en ext2 vers ext3 via la commande « tune2fs »
	➢ de convertir un SF en ext3 vers ext2 en supprimant le journal (non recommandé)
	➢ de convertir un SF en ext3 vers ext4 via la commande « tune2fs »
Mais il n’est pas possible (sans formater) de :
	➢ convertir un SF en NTFS vers FAT32
	➢ convertir un SF en ext4 vers ext3 (sauf si les « extends » ne sont pas utilisés)
## Conclusions
![[Pasted image 20230414130914.png]]
![[Pasted image 20230414130934.png]]
![[Pasted image 20230414130951.png]]
![[Pasted image 20230414131009.png]]
![[Pasted image 20230414131028.png]]
# systèmes de fichiers-add
## FAT
![[Pasted image 20230414132136.png]]
## NTFS
![[Pasted image 20230414132159.png]]
## EXT3
![[Pasted image 20230414132219.png]]
