# ordonnancement
## Définition
### Le problème
• Quand doit-on stopper un processus s'exécutant sur un CPU ?  
• Quel processus va continuer sur ce CPU ?  
• Mêmes questions pour les threads d'un processus.  
• Que se passe t’il avec plusieurs processeurs ?
### Les objectifs
✓ Maximiser le taux d'occupation du processeur  
✓ Minimiser le temps de réponse des processus  
Critères d'évaluations de l’ordonnancement :  
• Temps d'attente des processus  
• Débit du processeur  
• Temps de réponse moyen  
• Temps de traitement d'un ensemble de processus
### Les critères d'ordonnancement
Il y aura normalement plusieurs processus dans la file prêt  
Quand le CPU devient disponible, lequel choisir?  
Critères généraux:  
• Bonne utilisation du CPU  
• Réponse rapide à l’usager
Il y a aussi des critères spécifiques d’ordonnancement :  
Utilisation UCT: pourcentage d’utilisation (à maximiser).  
Débit = Throughput: nombre de processus qui s’exécutent complètement dans l’unité  
de temps (à maximiser).  
Temps de rotation = turnaround: le temps pris par le processus de son arrivée à sa  
fin (à minimiser).  
Temps d’attente: attente dans la file prêt (somme de tout le temps passé en file prêt)  
(à minimiser).  
Temps de réponse (pour les systèmes interactifs): le temps entre une demande et la  
réponse (à minimiser).
Nous distinguons deux types d’ordonnancement (concerne l’ordonnancement a court  
terme) :  
• Les mécanismes non-préemptifs qui n’interrompent pas le fonctionnement d’un  
processus : seul l’attente sur une entrée/sortie (qui peut stopper le fonctionnement  
d’un processus) et la fin d’un processus peuvent provoquer l’appel de l’ordonnanceur.  
• Les mécanismes préemptifs qui peuvent interrompre le fonctionnement d’un  
processus ce qui suppose la mise en place d’un timer et des méthodes plus  
complexes de gestion des changements de contexte.
### ordonnanceur et répartiteur
![image](https://user-images.githubusercontent.com/19058019/236696816-a2fb5c7c-968b-4062-b3bc-e5dd1990db0c.png)
### parallélisme réel et pseudo-parallélisme
![image](https://user-images.githubusercontent.com/19058019/236696833-0647603d-e8af-419e-95fa-860b471288e8.png)
## Les mécanismes
### Premier arrivé, premier servi FCFS (ou FIFO) sans ou avec réquisition
#### exemple
![image](https://user-images.githubusercontent.com/19058019/236696853-21cda22a-a675-4dca-aa14-47859851e504.png)
#### autre exemple
![image](https://user-images.githubusercontent.com/19058019/236696866-549927e8-f1a5-4ce9-a586-d25ec170878a.png)
• Donc dans un sens FCFS favorise les  
processus tributaires du CPU et peut  
conduire à une très mauvaise utilisation des  
ressources tant du CPU que de  
périphériques.  
• Une possibilité: interrompre de temps en  
temps les processus tributaires du CPU pour  
permettre aux autres processus d’exécuter  
(préemption)
### Plus court d'abord
Ce mécanisme consiste à sélectionner le processus nécessitant le moins de temps  
d’exécution (le prochain Burst CPU le plus court). Il existe deux approches :  
• Non-préemptive ; le processus qui prend le contrôle de l’UC ne le quitte qu’à la fin de  
son exécution ou lorsqu’il est bloqué.  
• Préemptive : si un nouveau processus arrive dont la durée prévue est inférieure au  
temps restant d’exécution du processus en cours, ce nouveau processus obtient le  
contrôle du CPU (on parle alors de SRIF, Shortest Remaining Time First)
#### Exemple
![image](https://user-images.githubusercontent.com/19058019/236696893-e83b85be-8bec-469c-83d1-9b722bcc61fb.png)
#### Exercices 1
![image](https://user-images.githubusercontent.com/19058019/236696916-94561b99-d706-4f55-a516-e04901c98f2c.png)
#### Exercice 2
![image](https://user-images.githubusercontent.com/19058019/236696939-66335770-2b6f-4441-a201-74e0887eadef.png)
![image](https://user-images.githubusercontent.com/19058019/236696948-64d5cf7f-7468-4e7b-9328-54567121a35f.png)
![image](https://user-images.githubusercontent.com/19058019/236696973-509a5832-9c6b-4cd0-aa62-7ab3c7baccd4.png)
![image](https://user-images.githubusercontent.com/19058019/236696992-e3b57d7b-d78c-4916-a958-318ae907994e.png)
### Par priorités constantes
Par priorités constantes  
• chaque processus reçoit une priorité  
• le processus de plus forte priorité est élu  
Avec ou sans réquisition (préemption)
![image](https://user-images.githubusercontent.com/19058019/236697020-16029a35-20c0-49ca-9579-89425d731617.png)
#### Exercice3
![image](https://user-images.githubusercontent.com/19058019/236697037-31913637-58a4-49db-b65a-1c376e35e83b.png)
### Par priorité : Rate Monotonic
![image](https://user-images.githubusercontent.com/19058019/236697048-f5f2be0a-300b-47cb-b561-413ff2b6d90b.png)
### Par tourniquet (round robin)
• Ce mécanisme est particulièrement utilisé  
dans les systèmes à temps partagé. Le  
planificateur alloue à tour de rôle à chaque  
processus un quota de temps du CPU (10 –  
100 ms).  
• Le processus en cours peut s'interrompre  
pour des raisons internes (ex : accès a un  
périphérique, fin du processus, etc) ou  
parce que le quota de temps alloué s'est  
écoulé. Dans le second cas il est remis  
dans la queue des processus prêts.
#### exemple
![image](https://user-images.githubusercontent.com/19058019/236697067-7dded5ec-2fd8-4eff-a0dc-e301fe2a89bf.png)
#### autre exemple
### Par files de priorités de priorités constantes multiniveaux avec ou sans extinction de priorité
L’ordonnancement  
Les mécanismes  
• Chaque file est associée à un quantum de temps éventuellement différent  
• sans extinction : un processus garde toujours la même priorité  
• avec extinction : la priorité d'un processus décroit en fonction de son utilisation du cpu
![image](https://user-images.githubusercontent.com/19058019/236697136-984b73c7-68dc-41b5-bfc8-625868da6021.png)
### Ordonnancement : système LINUX
![image](https://user-images.githubusercontent.com/19058019/236697243-edc1e1fb-912e-4b87-88cf-2ad49a7245c1.png)
## ex de cette partie
![[Système exploit theorie_230310_135602.pdf]]
![image](https://user-images.githubusercontent.com/19058019/236697352-39db90ab-f19a-4a76-a039-5d25e2b93dff.png)
![image](https://user-images.githubusercontent.com/19058019/236697363-cda2021f-3735-472c-9367-3dc3f6958a15.png)
![image](https://user-images.githubusercontent.com/19058019/236697383-a6fe1003-7c7f-42dc-88c1-5af9048ed26f.png)
![image](https://user-images.githubusercontent.com/19058019/236697415-561e381d-64eb-4fd3-8252-4376fac5334f.png)
![image](https://user-images.githubusercontent.com/19058019/236697424-25035664-9672-4e25-b253-f0701b3daf6c.png)
# gestion de la mémoire
## La fonction de mémorisation
Trois problèmes à résoudre vis-à-vis de la  
mémoire :  
❑Définir un espace d'adressage indépendant  
pour chaque processus  
❑Protéger les espaces d'adressages des processus  
entre eux  
❑Allouer de la mémoire physique à chaque espace  
d'adressage
## Le chargement dynamique en mémoire
![image](https://user-images.githubusercontent.com/19058019/236697455-a6b9a17a-4f6e-4a04-bc01-0ca5f84975cb.png)
## Le découpage de la mémoire
La mémoire centrale peut-être découpée de trois façons :  
◼ la segmentation : les programmes sont découpés en  
parcelles ayant des longueurs variables appelées  
«segments».  
◼ la pagination : elle consiste à diviser la mémoire en  
blocs, et les programmes en pages de longueur fixe.  
◼ une combinaison de segmentation et de pagination :  
certaines parties de la mémoires sont segmentées, les  
autres sont paginées.
## Organisation de la mémoire d’un processus
![image](https://user-images.githubusercontent.com/19058019/236697470-7a081de5-14d7-40db-954c-8a7272cffa77.png)
Le segment de code  
	Le segment de code est obtenu en copiant directement  
	en mémoire le segment de code du fichier exécutable.  
	Au cours de l'exécution du programme, la prochaine  
	instruction à exécuter est repérée par un pointeur  
	d'instruction.
Le segment de données  
	Au dessus du segment de code se trouve le segment  
	de données.  
	Ce segment est traditionnellement composé d'un  
	segment de données initialisées (data), qui est  
	directement copié à partir de l'exécutable, et d'un  
	segment de données non initialisées (bss pour block  
	storage segment) qui est créé dynamiquement.
![image](https://user-images.githubusercontent.com/19058019/236697480-63c5b6bc-342f-4a81-9701-de18e361ebe3.png)
	Les données initialisées correspondent à toutes les  
	variables globales et statiques initialisées des programmes  
	C. Les données non initialisées correspondent aux  
	variables globales et statiques non initialisées.  
	Le segment de données peut être agrandi ou réduit au  
	cours de l'exécution pour permettre d'y placer des  
	données. Néanmoins, il est habituel de considérer que ce  
	segment est fixe et correspond à celui obtenu avant  
	l'exécution de la première instruction : le segment bss se  
	résume alors aux variables locales de la fonction main().  
	La pile et le tas sont des zones variables.
Les autres informations  
	D'autres informations sont placées dans l'espace mémoire  
	du processus, comme les paramètres passés en ligne lors  
	de l'exécution du programme.  
	Suivant les systèmes d'exploitation, le système peut aussi  
	stocker différents renseignements, comme par exemple le  
	mode dans lequel doit s'exécuter le processus. Ces  
	renseignements se trouvent dans une structure qui se  
	nomme souvent Process Control Bloc (PCB).
Conclusion  
	L'espace mémoire d'un processus est donc divisé en deux  
	morceaux variables situés chacun à une extrémité de  
	l'espace. Ces morceaux sont eux-mêmes divisés en  
	plusieurs segments, certains de taille fixe situés aux  
	extrémités, d'autres de taille variable.  
	Suivant les systèmes d'exploitation, le tas et la pile  
	peuvent se trouver l'un en haut et l'autre en bas, ou  
	l'inverse.
## Organisation de la mémoire physique
## Pagination
La pagination constitue une approche permettant de  
réduire la fragmentation de la mémoire  
(fragmentation externe).  
L’espace des adresses logiques d’un processus est  
‘paginé’ :  
•Les pages sont indépendantes en terme d’adressage à  
l’intérieur de la mémoire et ne sont pas nécessairement  
contiguës  
•Le SE alloue la mémoire physique chaque fois que la  
nécessité de loger une page se présente.
![image](https://user-images.githubusercontent.com/19058019/236697516-313d61a8-4d68-4f6a-819d-7bd2276e1bdd.png)
Avantages et inconvénients:  
◼ Meilleure utilisation de la mémoire physique  
(programmes implantés par fragments, dans des pages  
non consécutives).  
◼ Possibilité de ne charger des pages que lorsqu'elles  
sont référencées (chargement à la demande).  
◼ Indépendance de l'espace virtuel et de la mémoire  
physique (mémoire virtuelle généralement plus grande).  
◼ Par contre, fragmentation interne (toutes les  
pages ne sont pas remplies).
## Pagination et Segmentation
![image](https://user-images.githubusercontent.com/19058019/236697528-8393e11a-4db6-4c4c-8f37-3acb14bcb5bb.png)
## Segmentation
![image](https://user-images.githubusercontent.com/19058019/236697551-ce2a865e-7f3c-4949-ba4e-7d1b514f6a2c.png)
![image](https://user-images.githubusercontent.com/19058019/236697565-83e017a6-b591-4ddf-a813-28f25307cd92.png)
Malheureusement, l’allocations et la  
désallocations successives des segments crée  
également un problème de fragmentation :  
On va alors combiner segmentation et pagination :  
→ paginer les segments
## Segmentation et Pagination
La segmentation et la pagination sont deux notions  
différentes qui sont utilisées conjointement.  
La segmentation doit être vue comme une structuration  
de l'espace des adresses d'un processus, alors que la  
pagination doit être vue comme un moyen d'adaptation  
de la mémoire virtuelle à la mémoire réelle
## Mémoire virtuelle
![image](https://user-images.githubusercontent.com/19058019/236697579-4560a0e7-9355-4932-8a67-d35a274a0dd9.png)
![image](https://user-images.githubusercontent.com/19058019/236697609-f3069056-4122-4d75-8d38-413ccd9a71ed.png)
![image](https://user-images.githubusercontent.com/19058019/236697617-dbca9bbc-b06a-498f-a015-a53f5f2a6964.png)
Bit de validation et défaut de page  
Ne charger que les pages utiles à un instant :  
→ il faut pouvoir tester la présence d'une page en  
mémoire centrale :  
→ rôle du bit de validation  
→ si un processus cherche à accéder à une page non  
présente en mémoire centrale, il se produit un  
déroutement de défaut de page  
	le système d'exploitation lance une entrée/sortie disque  
	pour charger la page en mémoire dans une case libre  
		→ perte de performances !
![image](https://user-images.githubusercontent.com/19058019/236697641-88722086-1160-421b-8f63-7ab4673ddf6f.png)
Les pages d'un processus ne sont chargées en mémoire  
centrale que lorsque le processus y accède  
❑ Lorsqu'un processus accède à une page non présente en  
mémoire centrale, il se produit un défaut de page.  
La page manquante est alors chargée dans une case libre.  
❑Si aucune case n'est libre, le système utilise un algorithme de  
remplacement de page pour choisir une case à libérer.  
❑ L'écroulement est la situation pour laquelle un ou plusieurs  
processus passent plus de temps à paginer qu'à s'exécuter.
# gestion des fichiers
## Les concepts
### Le concept de fichier
La mémoire centrale est une mémoire volatile :  
→ il faut stocker les données devant être conservées au delà de l'arrêt  
de la machine sur un support de masse permanent  
→ l'unité de conservation sur le support de masse est le fichier  
exemple : il faut conserver les programmes du système d'exploitation
Les données dans le fichier sont organisées  
selon les besoins de l'utilisateur sous forme  
d'enregistrements (articles, records)  
→ Fichier logique  
Système de Gestion de Fichiers :  
▪ accès aux données du fichier  
▪ allocation des fichiers sur le support de masse  
→ Fichier physique
### Fichier Logique
Un fichier logique est un ensemble d'enregistrements, désigné par un nom et accessible via des fonctions d'accès.  
Type de donnée standard  
▪ Identifié par un nom  
Fonctions standards  
▪ Création / ouverture /  
fermeture / destruction  
▪ Ensemble d’enregistrements = fichier  
logique  
▪ Enregistrement = groupe de données de  
types divers
#### Fichier à mode d’accès séquentiel
![image](https://user-images.githubusercontent.com/19058019/236697656-d1a6f089-8858-4079-9789-d671c023b9d3.png)
#### Fichier à mode d’accès indexé (ou aléatoire)
![image](https://user-images.githubusercontent.com/19058019/236697666-25bfcecc-3ac7-4f2f-bf51-db2b3af2c747.png)
#### Fichier à mode d’accès direct
![image](https://user-images.githubusercontent.com/19058019/236697682-3fd3acf5-3e86-42dc-af8a-d6eedd4f6eed.png)
### Fichier physique
![image](https://user-images.githubusercontent.com/19058019/236697699-223d1f1a-5b0e-43e2-97b7-81b734a4a37f.png)
#### Le bloc physique
Pour un meilleur compromis: temps d'accès et capacité de stockage certains SGF organisent l'espace du disque en blocs de secteurs  
Exemple : 1 bloc = 2 secteurs de 512 octets soit 1KO  
Les opérations de lecture et d'écriture du SGF se font bloc par bloc
![image](https://user-images.githubusercontent.com/19058019/236697712-0c64702e-a6da-4804-a58c-7ad0347bde9f.png)
#### Allocation de la mémoire
Les enregistrements logiques doivent être écrits dans les secteurs  
constituants les blocs  
→ il faut allouer les blocs physiques au fichier
![image](https://user-images.githubusercontent.com/19058019/236697728-a5e33cfd-8490-49f3-aeca-dfeaa1772301.png)
#### Allocation contigüe
![image](https://user-images.githubusercontent.com/19058019/236697742-cc46ac73-68cb-447f-8c66-005d48553a6c.png)
![image](https://user-images.githubusercontent.com/19058019/236697754-08ff2a96-e268-44c4-ab17-643dc82cb144.png)
#### Allocation par zones
![image](https://user-images.githubusercontent.com/19058019/236697765-04c24d78-ac11-42a8-a89a-e2e01ade2a1b.png)
#### Allocation par bloc chainés
![image](https://user-images.githubusercontent.com/19058019/236697779-8d1d64ca-52e2-4626-90e2-4d927060350f.png)
#### Allocation par bloc chainés – variante : FAT
![image](https://user-images.githubusercontent.com/19058019/236697793-33813acb-a646-47b5-ac9f-ca9c4abc9d2a.png)
#### Allocation indexée
→ Les adresses des blocs physiques constituant un fichier sont rangées dans une table appelée bloc d'index, elle même contenue dans un ou plusieurs blocs disque
![image](https://user-images.githubusercontent.com/19058019/236697805-5501cedb-3f08-476a-b075-85e5551246da.png)
#### Allocation indexée : solution UNIX
![image](https://user-images.githubusercontent.com/19058019/236697827-345107a3-93c4-4536-9e40-9ac17a72cb6f.png)
#### Allocation indexée : solution UNIX
![image](https://user-images.githubusercontent.com/19058019/236697839-686c339f-eda7-4c96-a5de-be4f493c874b.png)
![image](https://user-images.githubusercontent.com/19058019/236697880-70853162-a831-424b-8f5f-1637eb0ee9ec.png)
#### Gestion de l’espace libre
Le système maintient une liste d'espace libre, qui mémorise tous les blocs disque libres (non alloués)  
Création/extension d'un fichier : recherche dans la liste d'espace libre de la quantité requise d'espace et allocation au fichier :  
▪ l'espace alloué est supprimé de la liste  
Destruction d'un fichier : l'espace libéré est intégré à la liste d'espace libre  
Il existe différentes représentations possibles de l'espace libre  
▪ vecteur de bits  
▪ liste chainée des blocs libres
#### Gestion de l’espace libre par vecteur de bits
![image](https://user-images.githubusercontent.com/19058019/236697901-fe17b4a2-9ba6-438a-af44-b495d96656ee.png)
#### Gestion de l’espace libre par liste chainée
![image](https://user-images.githubusercontent.com/19058019/236697916-b647e1aa-a28b-4822-a971-0cdfa23a5e2a.png)
#### Gestion de l’espace libre : FAT
![image](https://user-images.githubusercontent.com/19058019/236697927-16b6dbc0-5258-4b18-9808-f50d62074e72.png)
### Correspondance, fichier logique / fichier physique
#### Désignation des fichiers : le répertoire
![image](https://user-images.githubusercontent.com/19058019/236697938-a1f0846d-3280-4e8f-8b45-df55ef5e9037.png)
#### Structure des répertoires
![image](https://user-images.githubusercontent.com/19058019/236698062-d4e4779c-d7ff-4d34-b33f-da3c33d6f2c5.png)
![image](https://user-images.githubusercontent.com/19058019/236698079-e3aef939-8d9a-4386-8fe7-6bb3c38b8fd7.png)
#### Volume ou partition
![image](https://user-images.githubusercontent.com/19058019/236698087-78a8bc73-c019-4ee4-b264-1d1ba5548e32.png)
#### Ex : partition FAT
![image](https://user-images.githubusercontent.com/19058019/236698264-a8e04390-754a-4e25-a445-9dc480b56fd0.png)
#### Ex : partition FAT – répertoire racine
![image](https://user-images.githubusercontent.com/19058019/236698369-461ea974-664e-41ba-8a1d-40528fcb5f8b.png)
#### Ex : UNIX
![image](https://user-images.githubusercontent.com/19058019/236698386-d1706b5b-dfdd-4630-bde5-cfd8035b4914.png)
## Réalisation des opérations
### Les commandes et les requêtes
Les commandes:  
• interface SGF utilisateurs  
• langage de commande ex: shell d'unix, commandes MS-DOS  
• Niveau des fichiers et non du contenu des fichiers
![image](https://user-images.githubusercontent.com/19058019/236698407-e41b5dc5-fdf9-42cb-8589-c7942ae54510.png)
Les requêtes (appels systèmes) :  
• interface SGF logiciel  
• appel dans un programme aux fonctions du SGF (langage C, Java...)  
• niveau fichier et enregistrements
![image](https://user-images.githubusercontent.com/19058019/236698429-b7adc43d-04fc-4776-9c0d-dfeb55bb2473.png)
Les commandes du S.E. incluent un certain nombre de commandes SGF  
→ Langage de commandes  
	Quelques commandes du SGF:  
	• liste du répertoire (ls, dir)  
	• changement de répertoire (cd)  
	• création répertoire (mkdir)  
	• suppression répertoire (rmdir)  
	• suppression fichier (rm, del)  
	• modification d'attributs d'un fichier (chmod)  
	• changement de nom de fichier... (mv, ren)
![image](https://user-images.githubusercontent.com/19058019/236698449-9123b1ff-6fec-4cb6-a151-21374eb0dfb1.png)
Les requêtes sont des appels aux fonctions SGF dans un programme.  
Les requêtes permettent de modifier le contenu des fichiers  
Quelques requêtes du SGF:  
• ouverture fichier (open)  
• création de fichier (create)  
• fermeture fichier (close)  
Et  
• lecture d'enregistrement (read)  
• écriture d'enregistrement (write)
### Exemple sous Dos
wtf rien dans le cours ?
### Exemple sous UNIX
wtf rien dans le cours ?
## protection des fichiers
### a. Protection contre les dégâts physiques
Utilisation de la redondance interne :  
• L'information existe en double exemplaire : une version primaire, une version secondaire  
• Le système maintient la cohérence entre les deux versions  
exemple : MSDOS dispose de deux exemplaires de la FAT  
Redondance par sauvegarde périodique :  
• sauvegarde complète : la totalité des objets est dupliquée même si ils n'ont pas été modifiés  
• sauvegarde incrémentale : seuls les objets modifiés depuis la  
dernière sauvegarde sont dupliqués.
### b. Protection contre les accès inappropriés
Définition de droits d'accès  
– lecture (r), écriture (w), exécution (x), destruction ...  
A chaque fichier est associé une liste d'accès, spécifiant pour chaque  
utilisateur, les types d'accès qui lui sont autorisés
![image](https://user-images.githubusercontent.com/19058019/236698474-c42865f5-fdcb-48f6-bce0-ae07fe0a683f.png)
Ainsi, dans le monde UNIX, nous différencions les droits standards suivants : lecture (r), écriture (w),  
exécution (x).  
Ces droits sont appliqués à chaque fichiers et peuvent être modifiés via la commande « chmod », en  
indiquant les valeurs décimales de chaque droit + le nom du fichier. (ex: chmod 750 file.txt)  
Les droits peuvent être calculés de la manière suivante :
![image](https://user-images.githubusercontent.com/19058019/236698486-83a75d24-328e-4077-8c4e-dbb171894afc.png)
La liste d'accès peut être longue et difficile à gérer
• définition de groupes auxquels sont associés des droits  
• un utilisateur hérite des droits du groupe auxquels il appartient
![image](https://user-images.githubusercontent.com/19058019/236698493-ccc88b6e-e137-425e-a659-c040e3cd92a3.png)
#### Exemple Unix
![image](https://user-images.githubusercontent.com/19058019/236698506-4855038e-16a7-48ec-9ec9-5e16b9f6de2b.png)
# systèmes de fichiers-V3
## Objectifs
![image](https://user-images.githubusercontent.com/19058019/236698518-da3d983c-7a61-4c91-82c7-1d5bb04d0189.png)
## Les différents Système de Fichiers
•Système de fichiers ?
	•Stockage et organisations de fichiers sur support
• Principe de stockage
	• FAT : Association nom/contenu : Table
	• Unix et i-node
	• NTFS : Base de données
• Les systèmes de fichiers les plus courants sont:
	FAT
	NTFS
	Ext2-3-4
	TMPFS
	VMFS
	NFS
	Et bien d’autres encore…
## Les méta-données
• Description du fichier (exemple pour Unix/Linux)
	Droits d’accès
	Date de dernier accès de modification (données et
	métadonnées
	Propriétaire et groupe propriétaire
	Taille du fichier
	Nombre d’autres i-nodes (liens) pointant vers le fichier
	Nombre de blocs utilisés par le fichier
	Type de fichier (simple, lien symbolique, répertoire,
	périphériqe, etc)
	Pointeur vers le contenu
## Les fonctions du SGF
Manipulation des fichiers
Allocation de la place sur mémoires secondaires
Localisation des fichiers
Sécurité et contrôle des fichiers
## La mémoire cache
Accès disque de l'ordre de 1 000 000 fois plus lents que accès mémoire
• Il faut minimiser le nombre d'accès disque
• Pour réduire les accès disques :
	- Bufferiser les commandes d'écriture et de lecture
	- Éviter les écritures inutiles
• Avantages :
	- Réduit le trafic disque
	- Protège contre certaines écritures ”concurrentes”
• Désavantages :
	- Problème lors d'un crash système
	- Recopie vers ou à partir du cache pour toute entrée-sortie
• Le statut d'un bloc cache est une combinaison des
états suivants :
	- verrouillé → l'accès est réservé à un processus
	- valide → les données contenues dans le bloc sont valides
	-  "à écrire" → les données du bloc doivent être écrites sur disque avant de ré-allouer le bloc
	- Actif → le noyau est en train d'écrire/lire le bloc sur le disque
	- Attendu → un processus attend la libération du bloc
## Systèmes journalisés
Problème à résoudre lié au cache :
	- À cause du cache, en cas d'interruption brutale, les
	informations devant être stockées sur le disque peuvent être
	perdues.
	- Ce problème est valable aussi bien pour les opérations
	d'écriture que d'effacement.
	- Nécessité de vérifier l'intégrité du disque en entier avec
	l'utilitaire fsck lors d'un crash.
	- Cette procédure peut être très longue.
	- Pour corriger ce problème → nouveau type de système de
	fichiers utilisant un autre principe de cache.
	- Réductions des opérations d'entrée/sortie sous la forme de
	transaction.
	- Une trace complète de toutes les transactions est conservée
	sous la forme d'un journal.
	- Lors d'un crash système il n'est plus nécessaire de vérifier
	l'intégralité du disque car nous savons quelles données était
	présentes ou non lors de l'incident.
	• Cohérence
	• Fichier de modification
	• Tolérance aux pannes et intégrité
	![image](https://user-images.githubusercontent.com/19058019/236698546-a897ac7b-39cc-4ee8-8ebc-faa86b2e1a4f.png)
## Les différents systèmes de fichiers
Dans ce chapitre, nous allons expliquer les différents SF suivants :
	❑ FAT (File Allocation Table) de Microsoft
	❑ NTFS (New Technology File System) de Microsoft
	❑ Ext2-3-4 (Extended file system) utilisé dans le monde UNIX
	❑ TMPFS (Temporary File System) utilisé dans l’embarqué
	❑ VMFS (Virtual Machine File System) utilisé dans les outils de virtualisation
	❑ NFS (Network File System) utilisé sous Linux pour le partage réseau
	❑ Et bien d’autres encore…
## FAT → File Allocation Table
• Système de fichiers de DOS
• Clusters → Blocs (groupe de secteurs)
• Index qui liste le contenu du disque
	- Liste chaînée (une table) indiquant l'état de chaque cluster
	bloc)
	- Permet de connaître l'emplacement des fichiers sur le disque
	- Conserve la structure du fichier en créant des liens vers les
	blocs constitutifs du fichier (un bloc contient des data +
	l’adresse du block suivant )
• Plusieurs versions :
	- FAT12 (12 bits)
	- FAT16/vfat (16 bits)
	- FAT32 (28/32 bits)
• Conçu par Microsoft en 1977 (Bill Gates)
• Destiné aux 1ère disquettes : moins d'1Mb
• FAT d'une disquette de 1.44 Mb ne fait que 4.5 Ko
### FAT - Structure
![image](https://user-images.githubusercontent.com/19058019/236698570-b2cc0ac7-e66d-445f-9253-25e1c3d53060.png)
Boot sector : métadonnées du système de fichiers
FAT : index
Répertoire racine (FAT16)
Clusters : blocs des fichiers et répertoires
### FAT - Clusters
![image](https://user-images.githubusercontent.com/19058019/236698572-fa08e702-09a4-4d27-a64e-a9fbb8c1ad07.png)
• La taille d'un cluster est défini au formatage
• Un cluster est égal à n secteurs (512 bytes)
• n est une puissance de 2
### FAT16 – Partitions
16 bits maximum pour adresser les clusters
Le nombre max de clusters est 216 = 65536 clusters
La taille d'un cluster est 2n * 512 byte contigus
Taille cluster augmente → taille partition augmente
Taille max partition = nbr clusters * taille cluster
	- Exemple :
	- Cluster de 1Kb → taille max partition FAT16 est 64Mb
	- Cluster de 10Kb → taille max partition FAT16 est 640Mb
	- Cluster de 32Kb → taille max partition FAT16 est 2Gb
### FAT12 – Disquette
• Message après avoir formaté une disquette 1,44Mb :
![image](https://user-images.githubusercontent.com/19058019/236698589-f9097e27-5c09-421c-a7a6-199c6b9ad7fa.png)
Un cluster → 512 octets (un secteur)
La taille de la disquette est de 1.457.664 octets
Nbre de cluster = 1.457.664 / 512 = 2.847 clusters
Avec 12 bits, on peut encoder 212 = 4096 clusters
### FAT – Fragmentation
• Un fichier occupe un nombre entier de clusters
• Exemple :
	Cluster de 8 secteurs → 8 * 512 octets = 4096 octets
	Si un fichier est composé de un caractère (1 octet)
	La place inutilisée dans le cluster est 4096 – 1 = 4095 octets
- Peux poser des problème d'espace avec beaucoup de petits fichiers et des clusters de grande taille
### FAT32 – Partitions
- 32 bits pour les entrées de la FAT
- Mais 4 bits sont réservés
- Le nbre max de clusters est 228 = 268435456 clusters
- La FAT32 peut contenir beaucoup plus de clusters que la FAT16 → limitation de la fragmentation
- Exemple :
	Une partition de 2Gb
	Clusters de 4Kb avec le système FAT32
	Clusters de 32Kb en FAT16
	Diminution de l'espace gaspillé par un facteur 8
### FAT – Table
• Index contenant une entrée par cluster de la partition
• Décrit le chaînage des clusters par fichier
• Chaque entrée contient le numéro du cluster suivant
• Des valeurs particulières indiquent la fin de fichier
![image](https://user-images.githubusercontent.com/19058019/236698608-16ab3af9-e2a3-4d19-b723-721bd6b231ef.png)
• Valeurs réservées :
![image](https://user-images.githubusercontent.com/19058019/236698610-2593124f-3a24-4eb4-aa82-0df900136b5f.png)
### FAT – Taille de la table
• nombre entrées FAT = taille partition / taille clusters
• taille FAT = nombre entrées FAT * taille entrée FAT
• Exemple :
	Volume FAT32 de 500Gb
	Cluster de 4Kb
	→ taille de la table FAT = 500Mb
	avec des clusters de 16Kb on réduit à 125Mb
- Taille max de d'une table FAT16 est 128Kb
- Une table FAT32 peut devenir très grosse
- Elle est chargée en RAM au démarrage du système
- Un grand volume FAT ralentit le démarrage du système
### FAT – Les répertoires
• Une entrée d'un répertoire contient 32 octets et est
constituée comme suit:
	- Le nom du fichier → 8 caractères avant le point et 3 après (8.3)
	-  Le nom doit commencer par une lettre et est insensible à la casse
	-  Des d'attributs : ARCHIVE, READ_ONLY, HIDDEN, SYSTEM, DIRECTORY, VOLUME_ID
	- L'heure et la date de dernière modification
	- Le numéro du premier cluster
	- La longueur utile en octet
	- De plus 10 octets sont inutilisés
![image](https://user-images.githubusercontent.com/19058019/236698623-63eb5c7f-805f-4ef1-9065-bdd9da0e6532.png)
### FAT – Noms longs : VFAT
• VFAT → Virtual FAT
• Possibilité de nom de 255 caractères
• Plusieurs entrées répertoire sont créées :
	- un alias en 8.3 pour les anciennes versions DOS
	- le nom complet est ajouté sur plusieurs entrées
	- chaque nouvelle entrée permet 13 caractères de plus
	- jusqu’à 20 de ces entrées peuvent être enchaînées (8.3+19*13)
• Entrée marquée ATTR_LONG_NAME
	ATTR_LONG_NAME = READ_ONLY + HIDDEN + SYSTEM + VOLUME_ID
• DOS ne comprend pas ATTR_LONG_NAME → compatibilité ascendante
### FAT – Répertoire racine
![image](https://user-images.githubusercontent.com/19058019/236698636-d79e2fda-5d55-4b13-8f33-4076269da02b.png)
• En FAT16
	- 512 entrées
	- emplacement fixe
	- allocation contiguë
• Lors de nom long, moins d'entrées sont possibles
	- 24 entrées si on utilise des noms de 255 caractères (512 / 21)
• En FAT32 c'est une chaîne de clusters ordinaire
	- permet de le positionner à un endroit quelconque du disque restrictions sur le nombre de répertoires racine abolies
### FAT – Avantages et inconvénients
Simple et connu par beaucoup d'OS
Taille des fichiers limitée à 4Gb
Pas de gestion d’attributs pour la protection d’accès
Pas adapté aux grandes partitions
Fragmentation des fichiers (surtout FAT16)
### FAT – FAT16 / FAT32
• FAT16 :
	- MS-DOS, Windows 95, Windows 98, Windows NT, Windows 2000 et quelques OS UNIX peuvent utiliser FAT16
	- Beaucoup d'outils existent en cas de corruption
	- Rapide et efficace pour des volumes jusqu'à 256Mb
	- 512 entrées maximum à la racine (moins avec noms longs)
	- la taille maximale d'un volume est de 4Gb (cluster de 64Kb)
	- perte d'espace lorsque la taille des clusters est plus grand
	32 – 1 = 4Gb
	- la taille maximale d'un fichier est de 2^32 – 1 = 4Gb
• FAT32 :
- meilleure allocation d'espace disque
- le répertoire racine étant une chaîne de cluster standard, il n'y a plus de restriction sur le nombre d'entrées
- plus robuste (ex : backup des structures de données critiques)
- plus lent au chargement (table plus grande)
- la taille maximale d'un volume est de 16Tb (cluster de 64Kb)
- la taille maximale d'un fichier est de 2^32 – 1 = 4Gb
## NTFS - New Technology File System
Développé par Microsoft
Natif de Windows NT
Successeur du système de fichiers FAT
Réponse aux demandes système multi-utilisateurs
Améliore les performances, la fiabilité et l'utilisation
de l'espace disque (16Tb)
### NTFS - Volume
La structure NTFS commence par un volume
Un volume correspond à une partition logique
Un disque peut contenir plusieurs volumes
Plusieurs disques peuvent être inclus dans un volume
Les volumes sont indépendants les uns des autres
Un volume NTFS ne contient pas de partitions
spécifiques, tout est « fichiers »
![image](https://user-images.githubusercontent.com/19058019/236698653-31fd1659-d16b-4884-b43e-8b96450184d5.png)
### NTFS – MFT : Master File Table
• Fichier des descripteurs de fichiers
• Toutes les données de structure, métadonnées,... sont contenues dans des fichiers
• Relocalisation facile des fichiers en cas de corruption disque
• Une entrée par fichier, incluant la MFT elle-même
![image](https://user-images.githubusercontent.com/19058019/236698669-64bbbca8-ef4b-4e5c-853d-eea933300a30.png)
• La taille d'une entrée est de 1Kb
• Les fichiers de métadonnées (pour construire le système de fichier) commence par un  $ 
- Par exemple : le fichier contenant la MFT est $Mft
![image](https://user-images.githubusercontent.com/19058019/236698685-a5534e14-7557-4edc-9096-f6f1dfe4bdda.png)
### NTFS – MFT
![image](https://user-images.githubusercontent.com/19058019/236698694-aeacc746-c1c3-4dfe-b447-d84bd9fd0639.png)
### NTFS – entrées MFT
• Collection d'attributs
- Nom de fichier
- Informations d’horodatage
- ...
• Chaque attribut a une longueur variable
• Attributs résidents
- description entièrement contenue dans l’enregistrement
• Attributs non-résidents
- description non entièrement contenue dans l’enregistrement
![image](https://user-images.githubusercontent.com/19058019/236698710-cf7aa2a3-4087-4dcf-be54-bc255c61de0f.png)
### NTFS – attributs
• Chaque attribut a une longueur variable qu'il annonce par un en-tête
• 3 attributs et une marque de fin
• Attribut $FILE_NAME (résident)
- Plusieurs possible (nom NTFS, nom DOS)
• Attribut STANDARD INFORMATION
- résident
- Dates : création, modification, accès
- Permissions DOS
- ID propriétaire
- ...
![image](https://user-images.githubusercontent.com/19058019/236698718-fb5ecfea-c388-402c-a93e-ba19f1231d75.png)
### NTFS – MFT
• Un fichier ajouté → une entrée ajoutée → MFT grandit
• Un fichier effacé → entrée marquée comme libre
• Un entrée libre peut être réutilisée mais l'espace disque utilisé par l'entrée n'est pas libérée
• La taille de la MFT ne diminue jamais
### NTFS – Structure
• $Boot
	- taille secteur, nb secteurs, nb secteurs par cluster, nb clusters par enregistrement MFT, LCN du premier cluster des MFT et MFTMirr...
• une zone « réservée » : buffer MFT pour $Mft
• les espaces fichiers et répertoires
• le fichier $MFTMirr
![image](https://user-images.githubusercontent.com/19058019/236698728-84fc9bdf-83fe-4825-953c-b61c267eaa74.png)
### NTFS – log file
• Fichier $LogFile
• Utilisé pour enregistrer toutes les opérations sur la structure du volume NTFS (ex : copy)
• Sert à récupérer le volume après une panne système
### NTFS – Files
• Attribut $DATA
- résident pour un "petit fichier", non résident pour un "grand fichier"
- Pour un petit répertoire, l'index des fichiers et sous-répertoires est contenu directement dans l'attribut
- Pour un fichier qui serait trop grand pour l'entrée MFT (1Kb), les données ne seront pas résidentes et seulement les informations pour localiser les données seront dans la MFT
![image](https://user-images.githubusercontent.com/19058019/236698741-04ce6538-fd56-4da6-92c8-9b4f301bab90.png)
### NTFS - Clusters
![image](https://user-images.githubusercontent.com/19058019/236698758-ecf0e59d-a3a1-444d-819c-3016809b1ec0.png)
La taille d'un cluster est défini au formatage
Un cluster est égal à n secteurs (512 bytes)
n est une puissance de 2
Les clusters sont numérotés à partir de 0
Le cluster 0 commence au secteur 0
### NTFS – LCN / VCN
• LCN
	- L'emplacement physique sur le disque est référencé par le « Logical Cluster Number »
	- Les LCNs sont la numérotation des clusters du début à la fin du volume
	- Pour convertir le LCN en adresse physique, il suffit de multiplier le LCN par la taille d'un cluster
• VCN
- L'emplacement des données dans un fichier est référencé par le « Virtual Cluster Number»
- Les VCNs ne sont pas nécessairement contigus
- Tout fichier commence par le VCN 0
### NTFS – $DATA_RUN
• Fichier non fragmenté:
	• 12 07 56 34 00
		• 1h (4bits) – 1 octets pour la longueur
		• 2h (4bits) – 2 octets pour le décalage
		• 07h – La longueur
		• 5634h – le décalage absolu
		• 00h – fin des RUN
	• Les données sont contenues sur 7 clusters à partir du LCN 5634h
	• 13 18 56 34 11 00
		• 1h (4bits) – 1 octets pour la longueur
		• 3h (4bits) – 3 octets pour le décalage
		• 18h – La longueur
		• 563411h – le décalage absolu
		• 00h – fin des RUN
	• Les données sont contenues sur 18h clusters à partir du LCN 536411h
	• 13 38 34 25 73 23 01 14 02 11 E5 00
	• Run1
		• 1 octets pour la longueur - 3 octets pour le décalage
		• 38h – La longueur
		• 342573h – le décalage absolu
	• Run 2
	• 2 octets pour la longueur - 3 octets pour le décalage
		• 0114h – La longueur
		• 0211E5h – le décalage relatif
	• Les données sont contenues sur 38h (56) clusters à partir du LCN
	342573h et 114h (276) clusters depuis le LCN 342573h + 0211E5h
### NTFS – permissions
• ACL : Access Control List
	• Les autorisations NTFS définissent :
	- qui peut accéder à un fichier/répertoire
	- quelles opérations lui sont permises
• Les permissions s'appliquent :
	- par fichier/répertoire
	- pour des opérations spécifiques (parcourir, lire, écrire, lire et exécuter, modifier, contrôle total)
	- à des utilisateurs ou groupes d’utilisateurs
![image](https://user-images.githubusercontent.com/19058019/236698775-8e59e24b-ab74-4975-8673-040a98465a95.png)
• Les ACL sont stockées dans le fichier système $Secure
• Quelques règles :
	- le refus l’emporte sur les autres autorisations
	- les autorisations sont cumulatives (pour un utilisateur membre de différents groupes)
	- les autorisations sont héritées du répertoire parent mais les autorisations explicites priment sur ces dernières
• unix utilise par défaut un système d’ACL plus simple :
	- ACL’s de taille fixe - user, group, others
### NTFS – conclusion
• Par rapport à FAT32
	- évolution vers de grands volumes (16Tb)
	- sécurité (permissions)
	- rapidité au démarrage (comparé à FAT)
	- fiabilité (redondance, emplacement fichiers système, journalisation)
	- sujet à fragmentation interne
	- sujet à la fragmentation des fichiers
	- sujet à dégradation des performances si MFT fragmentée
## EXT2 / EXT3 - Extended file system
• Extended file system ou ext est créé en avril 1992
• Premier système de fichiers spécifiquement pour Linux
• ext2
	- développé en 1993
	- limité (2 Tb)
• ext3
	- journalisation
• ext4
	- supporte jusqu'au Pb (1015)
### EXT2 / EXT3 - Bloc
• Bloc : plus petite unité qui peut être allouée
• La taille des blocs est un multiple de la taille d'un secteur
• Chaque bloc peut être alloué ou libre
• Un bloc peut être découpé en fragments
	- il peut contenir les derniers fragments de plusieurs fichiers
	- la taille des fragments dépend de celle des blocs
### EXT2 / EXT3 - Structure
• Boot: contient le programme de démarrage
• Les blocs sont organisés en groupes de blocs
• Groupes de blocs :
	- Super-bloc
	- Descripteurs du groupe
	- Bitmap des blocs
	- Bitmap des i-nodes
	- Tables des i-nodes
	- Blocs de données
![image](https://user-images.githubusercontent.com/19058019/236698800-eca98fc6-85bc-4cfc-8fd4-301cb21838cb.png)
• Le superbloc
	- contient des informations essentielles
	- nombre d’inodes libres
	- emplacement de la table des inodes
	- ...
	- répliquée au début de chaque groupe de blocs dont le numéro est une puissance de 3, 5 ou 7
• La table de description des blocs
	- elle commence dans le bloc 1
	- contient les informations des blocs du groupe
• Un bloc est utilisé pour le bitmap des blocs
	- chaque bit à 0 correspond à un bloc « unallocated » dans le groupe
	- chaque bit à 1 correspond un bloc « allocated »
• Un bloc est utilisé pour le bitmap des inodes
	- même rôle pour les i-nœuds libres ou alloués
![image](https://user-images.githubusercontent.com/19058019/236698812-c0590e40-a701-4490-aea5-a607e72f220c.png)
• Ces deux blocs sont utilisés lors de la recherche d'un emplacement libre pour la création d'un nouvel i-nœud ou de l'allocation d'un nouveau bloc à un fichier
• La table des Inodes
	- contient les inodes du groupe
• Les blocs de données (plus grande partie)
### EXT2 / EXT3 – Inodes / table des blocs
• Contient des pointeurs vers les blocs d'un fichier
• Les blocs qui constituent un fichier ne sont pas forcément contigus
• Chaque fichier est décrit par un i-noeud pour retrouver tous les fragments
• Un i-noeuds comporte en général 15 entrées
![image](https://user-images.githubusercontent.com/19058019/236698827-1bb69bdc-c936-42e2-b8d3-d765376867bf.png)
• Les entrées 0 à 11 pointent directement sur le bloc de données correspondant
	- Si un bloc fait 1024 octets, l'accès est direct pour tous les fichiers de taille inférieure à 12 x 1024 octets (12 Ko)
• L'entrée 12 pointe sur un bloc qui contient une table de blocs
	- cette table contient 256 entrées
	-  tailles de fichiers de 12 Ko + 256 * 1 Ko = 268 Ko
• L'entrée 13 permet une double indirection
	- les 256 blocs accessibles par la première indirection sont eux-mêmes des
	tables de blocs
	- la taille maximale de tels fichiers est alors de
	12 Ko + 256 * 1 Ko + 256 * 256 * 1 Ko = 65804 Ko
• L'entrée 14 permet une triple indirection
	- La taille maximale de tels fichiers est alors de
	12 Ko + 256 * 1 Ko + 256 * 256 * 1 Ko + 256 * 256 * 256 * 1 Ko
	= 16843020 Ko, soit plus de 16 Go
![image](https://user-images.githubusercontent.com/19058019/236698840-e9ecf6b8-c072-47e9-8853-bc22c3797fdc.png)
### EXT2 / EXT3 – Liens
![image](https://user-images.githubusercontent.com/19058019/236698848-55b50c8c-294c-4040-bdc1-ab26a52b7fd5.png)
### EXT2 / EXT3 – Liens physiques
- Chaque entrée d'un répertoire pointe sur un fichier
- Plusieurs entrées peuvent pointer vers un i-nœud
- Possibilité d'accéder au fichier par plusieurs chemins
- Ce sont des liens physiques (hard links)
- Suppression d'un fichier possible quand le nombre de liens physiques devient nul
### EXT2 / EXT3 – Liens symboliques
• Un lien symbolique est lui-même un fichier
• Le(s) bloc(s) de données contien(nen)t seulement le nom du fichier sur lequel il pointe, avec son chemin d'accès
• Un lien symbolique peut consommer plus d'espace disque qu'un lien physique
	- une entrée de la table des i-nœuds + le bloc qui contient le nom du
	fichier cible
### EXT2 / EXT3 – amélioration EXT3
• Journalisation (plus besoin de fsck)
• EXT2 peut être converti en EXT3 sans formatage, la seule modification à ajouter étant le journal
![image](https://user-images.githubusercontent.com/19058019/236698873-2c1725b1-ba18-4c12-8d2f-bc40ee49065d.png)
## TMPFS – Temporary File System
• Implémenté directement dans le noyau Linux depuis la version 2.6
• Apparaît comme un système de fichier
• Tout est stocké en mémoire
• Ce système de fichier est très utilisé dans les systèmes embarqués (à mémoire flash) afin de limiter les écritures sur le support pour ainsi augmenter sa durée de vie
### TMPFS – Avantages / Inconvénients
- Tous les fichiers sont effacés à chaque arrêt du système
- Vitesse d'accès aux fichiers accrue
- Économie de consommation électrique.
- Baisse de l'usure des disques
- Si la RAM est pleine → partition "swap"
- Un tmpfs de 1 GO ne prendra 1 GO de place dans la RAM que s'il est plein, il n'utilise que la place des fichiers qu'il contient
## VMFS – Virtual Machine File System
• Conçu spécifiquement pour la virtualisation
• Les systèmes de fichiers classiques ne permettent qu’à un seul serveur d’accéder à un système de fichier
• VMFS utilise le stockage partagé afin d’autoriser simultanément plusieurs hôtes à écrire et lire des données sur le même stockage
![image](https://user-images.githubusercontent.com/19058019/236698889-ffc78e2e-73f9-4188-acca-ad1f8beef6f8.png)
## NFS – Network File System
• Développé par Sun Microsystems en 1984
• Protocole qui permet d'accéder à un système de fichiers à distance par le réseau
• Pris en charge par tous les systèmes Unix
![image](https://user-images.githubusercontent.com/19058019/236698896-02b1d81f-42ab-46cc-8dda-e45ba5a0a417.png)
### NFS – Conversion des systèmes
Parmi les différents systèmes de fichiers abordés, il est (parfois)
possible de
convertir un SF vers un autre SF, c’est-à-dire utiliser un SF sans formater.
Ainsi donc, il est possible :
	➢ de convertir un SF en FAT32 vers NTFS via la commande « convert »
	➢ de convertir un SF en ext2 vers ext3 via la commande « tune2fs »
	➢ de convertir un SF en ext3 vers ext2 en supprimant le journal (non recommandé)
	➢ de convertir un SF en ext3 vers ext4 via la commande « tune2fs »
Mais il n’est pas possible (sans formater) de :
	➢ convertir un SF en NTFS vers FAT32
	➢ convertir un SF en ext4 vers ext3 (sauf si les « extends » ne sont pas utilisés)
## Conclusions
![image](https://user-images.githubusercontent.com/19058019/236698929-6c0ed5e0-ee86-46d8-99ba-1b0f267f1c88.png)
![image](https://user-images.githubusercontent.com/19058019/236698943-0baffd6d-48ae-499f-beab-86bbd71769a6.png)
![image](https://user-images.githubusercontent.com/19058019/236698950-b325fe88-8526-40ea-88be-1e8d26a713bd.png)
# systèmes de fichiers-add
## FAT
![[Pasted image 20230414132136.png]]
## NTFS
![[Pasted image 20230414132159.png]]
## EXT3
![[Pasted image 20230414132219.png]]
